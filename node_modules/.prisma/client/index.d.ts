
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Alternative
 * 
 */
export type Alternative = $Result.DefaultSelection<Prisma.$AlternativePayload>
/**
 * Model Simulation
 * 
 */
export type Simulation = $Result.DefaultSelection<Prisma.$SimulationPayload>
/**
 * Model SimulationAnswer
 * 
 */
export type SimulationAnswer = $Result.DefaultSelection<Prisma.$SimulationAnswerPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Board
 * 
 */
export type Board = $Result.DefaultSelection<Prisma.$BoardPayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model Notice
 * 
 */
export type Notice = $Result.DefaultSelection<Prisma.$NoticePayload>
/**
 * Model Career
 * 
 */
export type Career = $Result.DefaultSelection<Prisma.$CareerPayload>
/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model ExamRecord
 * 
 */
export type ExamRecord = $Result.DefaultSelection<Prisma.$ExamRecordPayload>
/**
 * Model ExamRecordCareer
 * 
 */
export type ExamRecordCareer = $Result.DefaultSelection<Prisma.$ExamRecordCareerPayload>
/**
 * Model ExamRecordArea
 * 
 */
export type ExamRecordArea = $Result.DefaultSelection<Prisma.$ExamRecordAreaPayload>
/**
 * Model ExamRecordPart
 * 
 */
export type ExamRecordPart = $Result.DefaultSelection<Prisma.$ExamRecordPartPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Exams
 * const exams = await prisma.exam.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Exams
   * const exams = await prisma.exam.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alternative`: Exposes CRUD operations for the **Alternative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alternatives
    * const alternatives = await prisma.alternative.findMany()
    * ```
    */
  get alternative(): Prisma.AlternativeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulation`: Exposes CRUD operations for the **Simulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Simulations
    * const simulations = await prisma.simulation.findMany()
    * ```
    */
  get simulation(): Prisma.SimulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulationAnswer`: Exposes CRUD operations for the **SimulationAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimulationAnswers
    * const simulationAnswers = await prisma.simulationAnswer.findMany()
    * ```
    */
  get simulationAnswer(): Prisma.SimulationAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.career`: Exposes CRUD operations for the **Career** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Careers
    * const careers = await prisma.career.findMany()
    * ```
    */
  get career(): Prisma.CareerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examRecord`: Exposes CRUD operations for the **ExamRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamRecords
    * const examRecords = await prisma.examRecord.findMany()
    * ```
    */
  get examRecord(): Prisma.ExamRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examRecordCareer`: Exposes CRUD operations for the **ExamRecordCareer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamRecordCareers
    * const examRecordCareers = await prisma.examRecordCareer.findMany()
    * ```
    */
  get examRecordCareer(): Prisma.ExamRecordCareerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examRecordArea`: Exposes CRUD operations for the **ExamRecordArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamRecordAreas
    * const examRecordAreas = await prisma.examRecordArea.findMany()
    * ```
    */
  get examRecordArea(): Prisma.ExamRecordAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examRecordPart`: Exposes CRUD operations for the **ExamRecordPart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamRecordParts
    * const examRecordParts = await prisma.examRecordPart.findMany()
    * ```
    */
  get examRecordPart(): Prisma.ExamRecordPartDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.1.0
   * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Exam: 'Exam',
    Question: 'Question',
    Alternative: 'Alternative',
    Simulation: 'Simulation',
    SimulationAnswer: 'SimulationAnswer',
    Organization: 'Organization',
    Board: 'Board',
    Position: 'Position',
    Notice: 'Notice',
    Career: 'Career',
    Area: 'Area',
    ExamRecord: 'ExamRecord',
    ExamRecordCareer: 'ExamRecordCareer',
    ExamRecordArea: 'ExamRecordArea',
    ExamRecordPart: 'ExamRecordPart'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "exam" | "question" | "alternative" | "simulation" | "simulationAnswer" | "organization" | "board" | "position" | "notice" | "career" | "area" | "examRecord" | "examRecordCareer" | "examRecordArea" | "examRecordPart"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Alternative: {
        payload: Prisma.$AlternativePayload<ExtArgs>
        fields: Prisma.AlternativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlternativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlternativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          findFirst: {
            args: Prisma.AlternativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlternativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          findMany: {
            args: Prisma.AlternativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>[]
          }
          create: {
            args: Prisma.AlternativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          createMany: {
            args: Prisma.AlternativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlternativeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>[]
          }
          delete: {
            args: Prisma.AlternativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          update: {
            args: Prisma.AlternativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          deleteMany: {
            args: Prisma.AlternativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlternativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlternativeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>[]
          }
          upsert: {
            args: Prisma.AlternativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          aggregate: {
            args: Prisma.AlternativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlternative>
          }
          groupBy: {
            args: Prisma.AlternativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlternativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlternativeCountArgs<ExtArgs>
            result: $Utils.Optional<AlternativeCountAggregateOutputType> | number
          }
        }
      }
      Simulation: {
        payload: Prisma.$SimulationPayload<ExtArgs>
        fields: Prisma.SimulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          findFirst: {
            args: Prisma.SimulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          findMany: {
            args: Prisma.SimulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          create: {
            args: Prisma.SimulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          createMany: {
            args: Prisma.SimulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          delete: {
            args: Prisma.SimulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          update: {
            args: Prisma.SimulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          deleteMany: {
            args: Prisma.SimulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          upsert: {
            args: Prisma.SimulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          aggregate: {
            args: Prisma.SimulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulation>
          }
          groupBy: {
            args: Prisma.SimulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationCountAggregateOutputType> | number
          }
        }
      }
      SimulationAnswer: {
        payload: Prisma.$SimulationAnswerPayload<ExtArgs>
        fields: Prisma.SimulationAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>
          }
          findFirst: {
            args: Prisma.SimulationAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>
          }
          findMany: {
            args: Prisma.SimulationAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>[]
          }
          create: {
            args: Prisma.SimulationAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>
          }
          createMany: {
            args: Prisma.SimulationAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>[]
          }
          delete: {
            args: Prisma.SimulationAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>
          }
          update: {
            args: Prisma.SimulationAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>
          }
          deleteMany: {
            args: Prisma.SimulationAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>[]
          }
          upsert: {
            args: Prisma.SimulationAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationAnswerPayload>
          }
          aggregate: {
            args: Prisma.SimulationAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulationAnswer>
          }
          groupBy: {
            args: Prisma.SimulationAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationAnswerCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Board: {
        payload: Prisma.$BoardPayload<ExtArgs>
        fields: Prisma.BoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoard>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      Notice: {
        payload: Prisma.$NoticePayload<ExtArgs>
        fields: Prisma.NoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findFirst: {
            args: Prisma.NoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findMany: {
            args: Prisma.NoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          create: {
            args: Prisma.NoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          createMany: {
            args: Prisma.NoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoticeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          delete: {
            args: Prisma.NoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          update: {
            args: Prisma.NoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          deleteMany: {
            args: Prisma.NoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoticeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          upsert: {
            args: Prisma.NoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          aggregate: {
            args: Prisma.NoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotice>
          }
          groupBy: {
            args: Prisma.NoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeCountAggregateOutputType> | number
          }
        }
      }
      Career: {
        payload: Prisma.$CareerPayload<ExtArgs>
        fields: Prisma.CareerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          findFirst: {
            args: Prisma.CareerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          findMany: {
            args: Prisma.CareerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>[]
          }
          create: {
            args: Prisma.CareerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          createMany: {
            args: Prisma.CareerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CareerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>[]
          }
          delete: {
            args: Prisma.CareerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          update: {
            args: Prisma.CareerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          deleteMany: {
            args: Prisma.CareerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CareerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>[]
          }
          upsert: {
            args: Prisma.CareerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerPayload>
          }
          aggregate: {
            args: Prisma.CareerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareer>
          }
          groupBy: {
            args: Prisma.CareerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CareerCountArgs<ExtArgs>
            result: $Utils.Optional<CareerCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      ExamRecord: {
        payload: Prisma.$ExamRecordPayload<ExtArgs>
        fields: Prisma.ExamRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>
          }
          findFirst: {
            args: Prisma.ExamRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>
          }
          findMany: {
            args: Prisma.ExamRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>[]
          }
          create: {
            args: Prisma.ExamRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>
          }
          createMany: {
            args: Prisma.ExamRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>[]
          }
          delete: {
            args: Prisma.ExamRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>
          }
          update: {
            args: Prisma.ExamRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>
          }
          deleteMany: {
            args: Prisma.ExamRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>[]
          }
          upsert: {
            args: Prisma.ExamRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPayload>
          }
          aggregate: {
            args: Prisma.ExamRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamRecord>
          }
          groupBy: {
            args: Prisma.ExamRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordCountAggregateOutputType> | number
          }
        }
      }
      ExamRecordCareer: {
        payload: Prisma.$ExamRecordCareerPayload<ExtArgs>
        fields: Prisma.ExamRecordCareerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamRecordCareerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamRecordCareerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>
          }
          findFirst: {
            args: Prisma.ExamRecordCareerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamRecordCareerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>
          }
          findMany: {
            args: Prisma.ExamRecordCareerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>[]
          }
          create: {
            args: Prisma.ExamRecordCareerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>
          }
          createMany: {
            args: Prisma.ExamRecordCareerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamRecordCareerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>[]
          }
          delete: {
            args: Prisma.ExamRecordCareerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>
          }
          update: {
            args: Prisma.ExamRecordCareerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>
          }
          deleteMany: {
            args: Prisma.ExamRecordCareerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamRecordCareerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamRecordCareerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>[]
          }
          upsert: {
            args: Prisma.ExamRecordCareerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordCareerPayload>
          }
          aggregate: {
            args: Prisma.ExamRecordCareerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamRecordCareer>
          }
          groupBy: {
            args: Prisma.ExamRecordCareerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordCareerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamRecordCareerCountArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordCareerCountAggregateOutputType> | number
          }
        }
      }
      ExamRecordArea: {
        payload: Prisma.$ExamRecordAreaPayload<ExtArgs>
        fields: Prisma.ExamRecordAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamRecordAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamRecordAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>
          }
          findFirst: {
            args: Prisma.ExamRecordAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamRecordAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>
          }
          findMany: {
            args: Prisma.ExamRecordAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>[]
          }
          create: {
            args: Prisma.ExamRecordAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>
          }
          createMany: {
            args: Prisma.ExamRecordAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamRecordAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>[]
          }
          delete: {
            args: Prisma.ExamRecordAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>
          }
          update: {
            args: Prisma.ExamRecordAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>
          }
          deleteMany: {
            args: Prisma.ExamRecordAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamRecordAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamRecordAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>[]
          }
          upsert: {
            args: Prisma.ExamRecordAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordAreaPayload>
          }
          aggregate: {
            args: Prisma.ExamRecordAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamRecordArea>
          }
          groupBy: {
            args: Prisma.ExamRecordAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamRecordAreaCountArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordAreaCountAggregateOutputType> | number
          }
        }
      }
      ExamRecordPart: {
        payload: Prisma.$ExamRecordPartPayload<ExtArgs>
        fields: Prisma.ExamRecordPartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamRecordPartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamRecordPartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>
          }
          findFirst: {
            args: Prisma.ExamRecordPartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamRecordPartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>
          }
          findMany: {
            args: Prisma.ExamRecordPartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>[]
          }
          create: {
            args: Prisma.ExamRecordPartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>
          }
          createMany: {
            args: Prisma.ExamRecordPartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamRecordPartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>[]
          }
          delete: {
            args: Prisma.ExamRecordPartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>
          }
          update: {
            args: Prisma.ExamRecordPartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>
          }
          deleteMany: {
            args: Prisma.ExamRecordPartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamRecordPartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamRecordPartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>[]
          }
          upsert: {
            args: Prisma.ExamRecordPartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamRecordPartPayload>
          }
          aggregate: {
            args: Prisma.ExamRecordPartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamRecordPart>
          }
          groupBy: {
            args: Prisma.ExamRecordPartGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordPartGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamRecordPartCountArgs<ExtArgs>
            result: $Utils.Optional<ExamRecordPartCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    exam?: ExamOmit
    question?: QuestionOmit
    alternative?: AlternativeOmit
    simulation?: SimulationOmit
    simulationAnswer?: SimulationAnswerOmit
    organization?: OrganizationOmit
    board?: BoardOmit
    position?: PositionOmit
    notice?: NoticeOmit
    career?: CareerOmit
    area?: AreaOmit
    examRecord?: ExamRecordOmit
    examRecordCareer?: ExamRecordCareerOmit
    examRecordArea?: ExamRecordAreaOmit
    examRecordPart?: ExamRecordPartOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    questions: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ExamCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    alternatives: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alternatives?: boolean | QuestionCountOutputTypeCountAlternativesArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAlternativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternativeWhereInput
  }


  /**
   * Count Type SimulationCountOutputType
   */

  export type SimulationCountOutputType = {
    answers: number
  }

  export type SimulationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | SimulationCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationCountOutputType
     */
    select?: SimulationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationAnswerWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    examRecords: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | OrganizationCountOutputTypeCountExamRecordsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountExamRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordWhereInput
  }


  /**
   * Count Type BoardCountOutputType
   */

  export type BoardCountOutputType = {
    examRecords: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | BoardCountOutputTypeCountExamRecordsArgs
  }

  // Custom InputTypes
  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountExamRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    examRecords: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | PositionCountOutputTypeCountExamRecordsArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountExamRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordWhereInput
  }


  /**
   * Count Type NoticeCountOutputType
   */

  export type NoticeCountOutputType = {
    examRecords: number
  }

  export type NoticeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | NoticeCountOutputTypeCountExamRecordsArgs
  }

  // Custom InputTypes
  /**
   * NoticeCountOutputType without action
   */
  export type NoticeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeCountOutputType
     */
    select?: NoticeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NoticeCountOutputType without action
   */
  export type NoticeCountOutputTypeCountExamRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordWhereInput
  }


  /**
   * Count Type CareerCountOutputType
   */

  export type CareerCountOutputType = {
    exams: number
  }

  export type CareerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | CareerCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerCountOutputType
     */
    select?: CareerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CareerCountOutputType without action
   */
  export type CareerCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordCareerWhereInput
  }


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    exams: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | AreaCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordAreaWhereInput
  }


  /**
   * Count Type ExamRecordCountOutputType
   */

  export type ExamRecordCountOutputType = {
    careers: number
    areas: number
    parts: number
  }

  export type ExamRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careers?: boolean | ExamRecordCountOutputTypeCountCareersArgs
    areas?: boolean | ExamRecordCountOutputTypeCountAreasArgs
    parts?: boolean | ExamRecordCountOutputTypeCountPartsArgs
  }

  // Custom InputTypes
  /**
   * ExamRecordCountOutputType without action
   */
  export type ExamRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCountOutputType
     */
    select?: ExamRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamRecordCountOutputType without action
   */
  export type ExamRecordCountOutputTypeCountCareersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordCareerWhereInput
  }

  /**
   * ExamRecordCountOutputType without action
   */
  export type ExamRecordCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordAreaWhereInput
  }

  /**
   * ExamRecordCountOutputType without action
   */
  export type ExamRecordCountOutputTypeCountPartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordPartWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    year: number | null
  }

  export type ExamSumAggregateOutputType = {
    year: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    year: number | null
    organization: string | null
    institution: string | null
    level: string | null
    sourceUrl: string | null
    examPdfUrl: string | null
    answerKeyUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    year: number | null
    organization: string | null
    institution: string | null
    level: string | null
    sourceUrl: string | null
    examPdfUrl: string | null
    answerKeyUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    year: number
    organization: number
    institution: number
    level: number
    sourceUrl: number
    examPdfUrl: number
    answerKeyUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    year?: true
  }

  export type ExamSumAggregateInputType = {
    year?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    year?: true
    organization?: true
    institution?: true
    level?: true
    sourceUrl?: true
    examPdfUrl?: true
    answerKeyUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    year?: true
    organization?: true
    institution?: true
    level?: true
    sourceUrl?: true
    examPdfUrl?: true
    answerKeyUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    year?: true
    organization?: true
    institution?: true
    level?: true
    sourceUrl?: true
    examPdfUrl?: true
    answerKeyUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    year: number
    organization: string
    institution: string
    level: string
    sourceUrl: string | null
    examPdfUrl: string | null
    answerKeyUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    organization?: boolean
    institution?: boolean
    level?: boolean
    sourceUrl?: boolean
    examPdfUrl?: boolean
    answerKeyUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    organization?: boolean
    institution?: boolean
    level?: boolean
    sourceUrl?: boolean
    examPdfUrl?: boolean
    answerKeyUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    organization?: boolean
    institution?: boolean
    level?: boolean
    sourceUrl?: boolean
    examPdfUrl?: boolean
    answerKeyUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    year?: boolean
    organization?: boolean
    institution?: boolean
    level?: boolean
    sourceUrl?: boolean
    examPdfUrl?: boolean
    answerKeyUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "year" | "organization" | "institution" | "level" | "sourceUrl" | "examPdfUrl" | "answerKeyUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      questions: Prisma.$QuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      year: number
      organization: string
      institution: string
      level: string
      sourceUrl: string | null
      examPdfUrl: string | null
      answerKeyUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Exam$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly year: FieldRef<"Exam", 'Int'>
    readonly organization: FieldRef<"Exam", 'String'>
    readonly institution: FieldRef<"Exam", 'String'>
    readonly level: FieldRef<"Exam", 'String'>
    readonly sourceUrl: FieldRef<"Exam", 'String'>
    readonly examPdfUrl: FieldRef<"Exam", 'String'>
    readonly answerKeyUrl: FieldRef<"Exam", 'String'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam.questions
   */
  export type Exam$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    statement: string | null
    organization: string | null
    subject: string | null
    examId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    statement: string | null
    organization: string | null
    subject: string | null
    examId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    statement: number
    organization: number
    subject: number
    examId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionMinAggregateInputType = {
    id?: true
    statement?: true
    organization?: true
    subject?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    statement?: true
    organization?: true
    subject?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    statement?: true
    organization?: true
    subject?: true
    examId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    statement: string
    organization: string
    subject: string
    examId: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statement?: boolean
    organization?: boolean
    subject?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | Question$examArgs<ExtArgs>
    alternatives?: boolean | Question$alternativesArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statement?: boolean
    organization?: boolean
    subject?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | Question$examArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statement?: boolean
    organization?: boolean
    subject?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | Question$examArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    statement?: boolean
    organization?: boolean
    subject?: boolean
    examId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "statement" | "organization" | "subject" | "examId" | "createdAt" | "updatedAt", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | Question$examArgs<ExtArgs>
    alternatives?: boolean | Question$alternativesArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | Question$examArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | Question$examArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs> | null
      alternatives: Prisma.$AlternativePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      statement: string
      organization: string
      subject: string
      examId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends Question$examArgs<ExtArgs> = {}>(args?: Subset<T, Question$examArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    alternatives<T extends Question$alternativesArgs<ExtArgs> = {}>(args?: Subset<T, Question$alternativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly statement: FieldRef<"Question", 'String'>
    readonly organization: FieldRef<"Question", 'String'>
    readonly subject: FieldRef<"Question", 'String'>
    readonly examId: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.exam
   */
  export type Question$examArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
  }

  /**
   * Question.alternatives
   */
  export type Question$alternativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    where?: AlternativeWhereInput
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    cursor?: AlternativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Alternative
   */

  export type AggregateAlternative = {
    _count: AlternativeCountAggregateOutputType | null
    _min: AlternativeMinAggregateOutputType | null
    _max: AlternativeMaxAggregateOutputType | null
  }

  export type AlternativeMinAggregateOutputType = {
    id: string | null
    text: string | null
    isCorrect: boolean | null
    questionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlternativeMaxAggregateOutputType = {
    id: string | null
    text: string | null
    isCorrect: boolean | null
    questionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlternativeCountAggregateOutputType = {
    id: number
    text: number
    isCorrect: number
    questionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlternativeMinAggregateInputType = {
    id?: true
    text?: true
    isCorrect?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlternativeMaxAggregateInputType = {
    id?: true
    text?: true
    isCorrect?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlternativeCountAggregateInputType = {
    id?: true
    text?: true
    isCorrect?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlternativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alternative to aggregate.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alternatives
    **/
    _count?: true | AlternativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlternativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlternativeMaxAggregateInputType
  }

  export type GetAlternativeAggregateType<T extends AlternativeAggregateArgs> = {
        [P in keyof T & keyof AggregateAlternative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlternative[P]>
      : GetScalarType<T[P], AggregateAlternative[P]>
  }




  export type AlternativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternativeWhereInput
    orderBy?: AlternativeOrderByWithAggregationInput | AlternativeOrderByWithAggregationInput[]
    by: AlternativeScalarFieldEnum[] | AlternativeScalarFieldEnum
    having?: AlternativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlternativeCountAggregateInputType | true
    _min?: AlternativeMinAggregateInputType
    _max?: AlternativeMaxAggregateInputType
  }

  export type AlternativeGroupByOutputType = {
    id: string
    text: string
    isCorrect: boolean
    questionId: string
    createdAt: Date
    updatedAt: Date
    _count: AlternativeCountAggregateOutputType | null
    _min: AlternativeMinAggregateOutputType | null
    _max: AlternativeMaxAggregateOutputType | null
  }

  type GetAlternativeGroupByPayload<T extends AlternativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlternativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlternativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlternativeGroupByOutputType[P]>
            : GetScalarType<T[P], AlternativeGroupByOutputType[P]>
        }
      >
    >


  export type AlternativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    questionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternative"]>

  export type AlternativeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    questionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternative"]>

  export type AlternativeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    questionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternative"]>

  export type AlternativeSelectScalar = {
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    questionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlternativeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "isCorrect" | "questionId" | "createdAt" | "updatedAt", ExtArgs["result"]["alternative"]>
  export type AlternativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type AlternativeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type AlternativeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $AlternativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alternative"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      isCorrect: boolean
      questionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alternative"]>
    composites: {}
  }

  type AlternativeGetPayload<S extends boolean | null | undefined | AlternativeDefaultArgs> = $Result.GetResult<Prisma.$AlternativePayload, S>

  type AlternativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlternativeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlternativeCountAggregateInputType | true
    }

  export interface AlternativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alternative'], meta: { name: 'Alternative' } }
    /**
     * Find zero or one Alternative that matches the filter.
     * @param {AlternativeFindUniqueArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlternativeFindUniqueArgs>(args: SelectSubset<T, AlternativeFindUniqueArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alternative that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlternativeFindUniqueOrThrowArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlternativeFindUniqueOrThrowArgs>(args: SelectSubset<T, AlternativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alternative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeFindFirstArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlternativeFindFirstArgs>(args?: SelectSubset<T, AlternativeFindFirstArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alternative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeFindFirstOrThrowArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlternativeFindFirstOrThrowArgs>(args?: SelectSubset<T, AlternativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alternatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alternatives
     * const alternatives = await prisma.alternative.findMany()
     * 
     * // Get first 10 Alternatives
     * const alternatives = await prisma.alternative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alternativeWithIdOnly = await prisma.alternative.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlternativeFindManyArgs>(args?: SelectSubset<T, AlternativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alternative.
     * @param {AlternativeCreateArgs} args - Arguments to create a Alternative.
     * @example
     * // Create one Alternative
     * const Alternative = await prisma.alternative.create({
     *   data: {
     *     // ... data to create a Alternative
     *   }
     * })
     * 
     */
    create<T extends AlternativeCreateArgs>(args: SelectSubset<T, AlternativeCreateArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alternatives.
     * @param {AlternativeCreateManyArgs} args - Arguments to create many Alternatives.
     * @example
     * // Create many Alternatives
     * const alternative = await prisma.alternative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlternativeCreateManyArgs>(args?: SelectSubset<T, AlternativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alternatives and returns the data saved in the database.
     * @param {AlternativeCreateManyAndReturnArgs} args - Arguments to create many Alternatives.
     * @example
     * // Create many Alternatives
     * const alternative = await prisma.alternative.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alternatives and only return the `id`
     * const alternativeWithIdOnly = await prisma.alternative.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlternativeCreateManyAndReturnArgs>(args?: SelectSubset<T, AlternativeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alternative.
     * @param {AlternativeDeleteArgs} args - Arguments to delete one Alternative.
     * @example
     * // Delete one Alternative
     * const Alternative = await prisma.alternative.delete({
     *   where: {
     *     // ... filter to delete one Alternative
     *   }
     * })
     * 
     */
    delete<T extends AlternativeDeleteArgs>(args: SelectSubset<T, AlternativeDeleteArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alternative.
     * @param {AlternativeUpdateArgs} args - Arguments to update one Alternative.
     * @example
     * // Update one Alternative
     * const alternative = await prisma.alternative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlternativeUpdateArgs>(args: SelectSubset<T, AlternativeUpdateArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alternatives.
     * @param {AlternativeDeleteManyArgs} args - Arguments to filter Alternatives to delete.
     * @example
     * // Delete a few Alternatives
     * const { count } = await prisma.alternative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlternativeDeleteManyArgs>(args?: SelectSubset<T, AlternativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alternatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alternatives
     * const alternative = await prisma.alternative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlternativeUpdateManyArgs>(args: SelectSubset<T, AlternativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alternatives and returns the data updated in the database.
     * @param {AlternativeUpdateManyAndReturnArgs} args - Arguments to update many Alternatives.
     * @example
     * // Update many Alternatives
     * const alternative = await prisma.alternative.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alternatives and only return the `id`
     * const alternativeWithIdOnly = await prisma.alternative.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlternativeUpdateManyAndReturnArgs>(args: SelectSubset<T, AlternativeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alternative.
     * @param {AlternativeUpsertArgs} args - Arguments to update or create a Alternative.
     * @example
     * // Update or create a Alternative
     * const alternative = await prisma.alternative.upsert({
     *   create: {
     *     // ... data to create a Alternative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alternative we want to update
     *   }
     * })
     */
    upsert<T extends AlternativeUpsertArgs>(args: SelectSubset<T, AlternativeUpsertArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alternatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeCountArgs} args - Arguments to filter Alternatives to count.
     * @example
     * // Count the number of Alternatives
     * const count = await prisma.alternative.count({
     *   where: {
     *     // ... the filter for the Alternatives we want to count
     *   }
     * })
    **/
    count<T extends AlternativeCountArgs>(
      args?: Subset<T, AlternativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlternativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alternative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlternativeAggregateArgs>(args: Subset<T, AlternativeAggregateArgs>): Prisma.PrismaPromise<GetAlternativeAggregateType<T>>

    /**
     * Group by Alternative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlternativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlternativeGroupByArgs['orderBy'] }
        : { orderBy?: AlternativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlternativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlternativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alternative model
   */
  readonly fields: AlternativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alternative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlternativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alternative model
   */
  interface AlternativeFieldRefs {
    readonly id: FieldRef<"Alternative", 'String'>
    readonly text: FieldRef<"Alternative", 'String'>
    readonly isCorrect: FieldRef<"Alternative", 'Boolean'>
    readonly questionId: FieldRef<"Alternative", 'String'>
    readonly createdAt: FieldRef<"Alternative", 'DateTime'>
    readonly updatedAt: FieldRef<"Alternative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alternative findUnique
   */
  export type AlternativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative findUniqueOrThrow
   */
  export type AlternativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative findFirst
   */
  export type AlternativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alternatives.
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alternatives.
     */
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Alternative findFirstOrThrow
   */
  export type AlternativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alternatives.
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alternatives.
     */
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Alternative findMany
   */
  export type AlternativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternatives to fetch.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alternatives.
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Alternative create
   */
  export type AlternativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * The data needed to create a Alternative.
     */
    data: XOR<AlternativeCreateInput, AlternativeUncheckedCreateInput>
  }

  /**
   * Alternative createMany
   */
  export type AlternativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alternatives.
     */
    data: AlternativeCreateManyInput | AlternativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alternative createManyAndReturn
   */
  export type AlternativeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * The data used to create many Alternatives.
     */
    data: AlternativeCreateManyInput | AlternativeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alternative update
   */
  export type AlternativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * The data needed to update a Alternative.
     */
    data: XOR<AlternativeUpdateInput, AlternativeUncheckedUpdateInput>
    /**
     * Choose, which Alternative to update.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative updateMany
   */
  export type AlternativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alternatives.
     */
    data: XOR<AlternativeUpdateManyMutationInput, AlternativeUncheckedUpdateManyInput>
    /**
     * Filter which Alternatives to update
     */
    where?: AlternativeWhereInput
    /**
     * Limit how many Alternatives to update.
     */
    limit?: number
  }

  /**
   * Alternative updateManyAndReturn
   */
  export type AlternativeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * The data used to update Alternatives.
     */
    data: XOR<AlternativeUpdateManyMutationInput, AlternativeUncheckedUpdateManyInput>
    /**
     * Filter which Alternatives to update
     */
    where?: AlternativeWhereInput
    /**
     * Limit how many Alternatives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alternative upsert
   */
  export type AlternativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * The filter to search for the Alternative to update in case it exists.
     */
    where: AlternativeWhereUniqueInput
    /**
     * In case the Alternative found by the `where` argument doesn't exist, create a new Alternative with this data.
     */
    create: XOR<AlternativeCreateInput, AlternativeUncheckedCreateInput>
    /**
     * In case the Alternative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlternativeUpdateInput, AlternativeUncheckedUpdateInput>
  }

  /**
   * Alternative delete
   */
  export type AlternativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter which Alternative to delete.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative deleteMany
   */
  export type AlternativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alternatives to delete
     */
    where?: AlternativeWhereInput
    /**
     * Limit how many Alternatives to delete.
     */
    limit?: number
  }

  /**
   * Alternative without action
   */
  export type AlternativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
  }


  /**
   * Model Simulation
   */

  export type AggregateSimulation = {
    _count: SimulationCountAggregateOutputType | null
    _min: SimulationMinAggregateOutputType | null
    _max: SimulationMaxAggregateOutputType | null
  }

  export type SimulationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    createdAt: Date | null
    finishedAt: Date | null
  }

  export type SimulationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    createdAt: Date | null
    finishedAt: Date | null
  }

  export type SimulationCountAggregateOutputType = {
    id: number
    studentId: number
    title: number
    createdAt: number
    finishedAt: number
    _all: number
  }


  export type SimulationMinAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    createdAt?: true
    finishedAt?: true
  }

  export type SimulationMaxAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    createdAt?: true
    finishedAt?: true
  }

  export type SimulationCountAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    createdAt?: true
    finishedAt?: true
    _all?: true
  }

  export type SimulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Simulation to aggregate.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Simulations
    **/
    _count?: true | SimulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationMaxAggregateInputType
  }

  export type GetSimulationAggregateType<T extends SimulationAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulation[P]>
      : GetScalarType<T[P], AggregateSimulation[P]>
  }




  export type SimulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationWhereInput
    orderBy?: SimulationOrderByWithAggregationInput | SimulationOrderByWithAggregationInput[]
    by: SimulationScalarFieldEnum[] | SimulationScalarFieldEnum
    having?: SimulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationCountAggregateInputType | true
    _min?: SimulationMinAggregateInputType
    _max?: SimulationMaxAggregateInputType
  }

  export type SimulationGroupByOutputType = {
    id: string
    studentId: string
    title: string
    createdAt: Date
    finishedAt: Date | null
    _count: SimulationCountAggregateOutputType | null
    _min: SimulationMinAggregateOutputType | null
    _max: SimulationMaxAggregateOutputType | null
  }

  type GetSimulationGroupByPayload<T extends SimulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationGroupByOutputType[P]>
        }
      >
    >


  export type SimulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    createdAt?: boolean
    finishedAt?: boolean
    answers?: boolean | Simulation$answersArgs<ExtArgs>
    _count?: boolean | SimulationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    createdAt?: boolean
    finishedAt?: boolean
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    createdAt?: boolean
    finishedAt?: boolean
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectScalar = {
    id?: boolean
    studentId?: boolean
    title?: boolean
    createdAt?: boolean
    finishedAt?: boolean
  }

  export type SimulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "title" | "createdAt" | "finishedAt", ExtArgs["result"]["simulation"]>
  export type SimulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | Simulation$answersArgs<ExtArgs>
    _count?: boolean | SimulationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SimulationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SimulationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SimulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Simulation"
    objects: {
      answers: Prisma.$SimulationAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      title: string
      createdAt: Date
      finishedAt: Date | null
    }, ExtArgs["result"]["simulation"]>
    composites: {}
  }

  type SimulationGetPayload<S extends boolean | null | undefined | SimulationDefaultArgs> = $Result.GetResult<Prisma.$SimulationPayload, S>

  type SimulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationCountAggregateInputType | true
    }

  export interface SimulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Simulation'], meta: { name: 'Simulation' } }
    /**
     * Find zero or one Simulation that matches the filter.
     * @param {SimulationFindUniqueArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationFindUniqueArgs>(args: SelectSubset<T, SimulationFindUniqueArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Simulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationFindUniqueOrThrowArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Simulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindFirstArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationFindFirstArgs>(args?: SelectSubset<T, SimulationFindFirstArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Simulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindFirstOrThrowArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Simulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Simulations
     * const simulations = await prisma.simulation.findMany()
     * 
     * // Get first 10 Simulations
     * const simulations = await prisma.simulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationWithIdOnly = await prisma.simulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationFindManyArgs>(args?: SelectSubset<T, SimulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Simulation.
     * @param {SimulationCreateArgs} args - Arguments to create a Simulation.
     * @example
     * // Create one Simulation
     * const Simulation = await prisma.simulation.create({
     *   data: {
     *     // ... data to create a Simulation
     *   }
     * })
     * 
     */
    create<T extends SimulationCreateArgs>(args: SelectSubset<T, SimulationCreateArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Simulations.
     * @param {SimulationCreateManyArgs} args - Arguments to create many Simulations.
     * @example
     * // Create many Simulations
     * const simulation = await prisma.simulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationCreateManyArgs>(args?: SelectSubset<T, SimulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Simulations and returns the data saved in the database.
     * @param {SimulationCreateManyAndReturnArgs} args - Arguments to create many Simulations.
     * @example
     * // Create many Simulations
     * const simulation = await prisma.simulation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Simulations and only return the `id`
     * const simulationWithIdOnly = await prisma.simulation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Simulation.
     * @param {SimulationDeleteArgs} args - Arguments to delete one Simulation.
     * @example
     * // Delete one Simulation
     * const Simulation = await prisma.simulation.delete({
     *   where: {
     *     // ... filter to delete one Simulation
     *   }
     * })
     * 
     */
    delete<T extends SimulationDeleteArgs>(args: SelectSubset<T, SimulationDeleteArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Simulation.
     * @param {SimulationUpdateArgs} args - Arguments to update one Simulation.
     * @example
     * // Update one Simulation
     * const simulation = await prisma.simulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationUpdateArgs>(args: SelectSubset<T, SimulationUpdateArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Simulations.
     * @param {SimulationDeleteManyArgs} args - Arguments to filter Simulations to delete.
     * @example
     * // Delete a few Simulations
     * const { count } = await prisma.simulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationDeleteManyArgs>(args?: SelectSubset<T, SimulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Simulations
     * const simulation = await prisma.simulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationUpdateManyArgs>(args: SelectSubset<T, SimulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Simulations and returns the data updated in the database.
     * @param {SimulationUpdateManyAndReturnArgs} args - Arguments to update many Simulations.
     * @example
     * // Update many Simulations
     * const simulation = await prisma.simulation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Simulations and only return the `id`
     * const simulationWithIdOnly = await prisma.simulation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Simulation.
     * @param {SimulationUpsertArgs} args - Arguments to update or create a Simulation.
     * @example
     * // Update or create a Simulation
     * const simulation = await prisma.simulation.upsert({
     *   create: {
     *     // ... data to create a Simulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Simulation we want to update
     *   }
     * })
     */
    upsert<T extends SimulationUpsertArgs>(args: SelectSubset<T, SimulationUpsertArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationCountArgs} args - Arguments to filter Simulations to count.
     * @example
     * // Count the number of Simulations
     * const count = await prisma.simulation.count({
     *   where: {
     *     // ... the filter for the Simulations we want to count
     *   }
     * })
    **/
    count<T extends SimulationCountArgs>(
      args?: Subset<T, SimulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationAggregateArgs>(args: Subset<T, SimulationAggregateArgs>): Prisma.PrismaPromise<GetSimulationAggregateType<T>>

    /**
     * Group by Simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationGroupByArgs['orderBy'] }
        : { orderBy?: SimulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Simulation model
   */
  readonly fields: SimulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Simulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends Simulation$answersArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Simulation model
   */
  interface SimulationFieldRefs {
    readonly id: FieldRef<"Simulation", 'String'>
    readonly studentId: FieldRef<"Simulation", 'String'>
    readonly title: FieldRef<"Simulation", 'String'>
    readonly createdAt: FieldRef<"Simulation", 'DateTime'>
    readonly finishedAt: FieldRef<"Simulation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Simulation findUnique
   */
  export type SimulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation findUniqueOrThrow
   */
  export type SimulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation findFirst
   */
  export type SimulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Simulations.
     */
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation findFirstOrThrow
   */
  export type SimulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Simulations.
     */
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation findMany
   */
  export type SimulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulations to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation create
   */
  export type SimulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The data needed to create a Simulation.
     */
    data: XOR<SimulationCreateInput, SimulationUncheckedCreateInput>
  }

  /**
   * Simulation createMany
   */
  export type SimulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Simulations.
     */
    data: SimulationCreateManyInput | SimulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Simulation createManyAndReturn
   */
  export type SimulationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * The data used to create many Simulations.
     */
    data: SimulationCreateManyInput | SimulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Simulation update
   */
  export type SimulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The data needed to update a Simulation.
     */
    data: XOR<SimulationUpdateInput, SimulationUncheckedUpdateInput>
    /**
     * Choose, which Simulation to update.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation updateMany
   */
  export type SimulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Simulations.
     */
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyInput>
    /**
     * Filter which Simulations to update
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to update.
     */
    limit?: number
  }

  /**
   * Simulation updateManyAndReturn
   */
  export type SimulationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * The data used to update Simulations.
     */
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyInput>
    /**
     * Filter which Simulations to update
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to update.
     */
    limit?: number
  }

  /**
   * Simulation upsert
   */
  export type SimulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The filter to search for the Simulation to update in case it exists.
     */
    where: SimulationWhereUniqueInput
    /**
     * In case the Simulation found by the `where` argument doesn't exist, create a new Simulation with this data.
     */
    create: XOR<SimulationCreateInput, SimulationUncheckedCreateInput>
    /**
     * In case the Simulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationUpdateInput, SimulationUncheckedUpdateInput>
  }

  /**
   * Simulation delete
   */
  export type SimulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter which Simulation to delete.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation deleteMany
   */
  export type SimulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Simulations to delete
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to delete.
     */
    limit?: number
  }

  /**
   * Simulation.answers
   */
  export type Simulation$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    where?: SimulationAnswerWhereInput
    orderBy?: SimulationAnswerOrderByWithRelationInput | SimulationAnswerOrderByWithRelationInput[]
    cursor?: SimulationAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationAnswerScalarFieldEnum | SimulationAnswerScalarFieldEnum[]
  }

  /**
   * Simulation without action
   */
  export type SimulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
  }


  /**
   * Model SimulationAnswer
   */

  export type AggregateSimulationAnswer = {
    _count: SimulationAnswerCountAggregateOutputType | null
    _min: SimulationAnswerMinAggregateOutputType | null
    _max: SimulationAnswerMaxAggregateOutputType | null
  }

  export type SimulationAnswerMinAggregateOutputType = {
    id: string | null
    simulationId: string | null
    questionId: string | null
    alternativeId: string | null
    createdAt: Date | null
  }

  export type SimulationAnswerMaxAggregateOutputType = {
    id: string | null
    simulationId: string | null
    questionId: string | null
    alternativeId: string | null
    createdAt: Date | null
  }

  export type SimulationAnswerCountAggregateOutputType = {
    id: number
    simulationId: number
    questionId: number
    alternativeId: number
    createdAt: number
    _all: number
  }


  export type SimulationAnswerMinAggregateInputType = {
    id?: true
    simulationId?: true
    questionId?: true
    alternativeId?: true
    createdAt?: true
  }

  export type SimulationAnswerMaxAggregateInputType = {
    id?: true
    simulationId?: true
    questionId?: true
    alternativeId?: true
    createdAt?: true
  }

  export type SimulationAnswerCountAggregateInputType = {
    id?: true
    simulationId?: true
    questionId?: true
    alternativeId?: true
    createdAt?: true
    _all?: true
  }

  export type SimulationAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationAnswer to aggregate.
     */
    where?: SimulationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationAnswers to fetch.
     */
    orderBy?: SimulationAnswerOrderByWithRelationInput | SimulationAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimulationAnswers
    **/
    _count?: true | SimulationAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationAnswerMaxAggregateInputType
  }

  export type GetSimulationAnswerAggregateType<T extends SimulationAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulationAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulationAnswer[P]>
      : GetScalarType<T[P], AggregateSimulationAnswer[P]>
  }




  export type SimulationAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationAnswerWhereInput
    orderBy?: SimulationAnswerOrderByWithAggregationInput | SimulationAnswerOrderByWithAggregationInput[]
    by: SimulationAnswerScalarFieldEnum[] | SimulationAnswerScalarFieldEnum
    having?: SimulationAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationAnswerCountAggregateInputType | true
    _min?: SimulationAnswerMinAggregateInputType
    _max?: SimulationAnswerMaxAggregateInputType
  }

  export type SimulationAnswerGroupByOutputType = {
    id: string
    simulationId: string
    questionId: string
    alternativeId: string
    createdAt: Date
    _count: SimulationAnswerCountAggregateOutputType | null
    _min: SimulationAnswerMinAggregateOutputType | null
    _max: SimulationAnswerMaxAggregateOutputType | null
  }

  type GetSimulationAnswerGroupByPayload<T extends SimulationAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationAnswerGroupByOutputType[P]>
        }
      >
    >


  export type SimulationAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    questionId?: boolean
    alternativeId?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationAnswer"]>

  export type SimulationAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    questionId?: boolean
    alternativeId?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationAnswer"]>

  export type SimulationAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    questionId?: boolean
    alternativeId?: boolean
    createdAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationAnswer"]>

  export type SimulationAnswerSelectScalar = {
    id?: boolean
    simulationId?: boolean
    questionId?: boolean
    alternativeId?: boolean
    createdAt?: boolean
  }

  export type SimulationAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "simulationId" | "questionId" | "alternativeId" | "createdAt", ExtArgs["result"]["simulationAnswer"]>
  export type SimulationAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type SimulationAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }
  export type SimulationAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
  }

  export type $SimulationAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimulationAnswer"
    objects: {
      simulation: Prisma.$SimulationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simulationId: string
      questionId: string
      alternativeId: string
      createdAt: Date
    }, ExtArgs["result"]["simulationAnswer"]>
    composites: {}
  }

  type SimulationAnswerGetPayload<S extends boolean | null | undefined | SimulationAnswerDefaultArgs> = $Result.GetResult<Prisma.$SimulationAnswerPayload, S>

  type SimulationAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationAnswerCountAggregateInputType | true
    }

  export interface SimulationAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimulationAnswer'], meta: { name: 'SimulationAnswer' } }
    /**
     * Find zero or one SimulationAnswer that matches the filter.
     * @param {SimulationAnswerFindUniqueArgs} args - Arguments to find a SimulationAnswer
     * @example
     * // Get one SimulationAnswer
     * const simulationAnswer = await prisma.simulationAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationAnswerFindUniqueArgs>(args: SelectSubset<T, SimulationAnswerFindUniqueArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SimulationAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationAnswerFindUniqueOrThrowArgs} args - Arguments to find a SimulationAnswer
     * @example
     * // Get one SimulationAnswer
     * const simulationAnswer = await prisma.simulationAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAnswerFindFirstArgs} args - Arguments to find a SimulationAnswer
     * @example
     * // Get one SimulationAnswer
     * const simulationAnswer = await prisma.simulationAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationAnswerFindFirstArgs>(args?: SelectSubset<T, SimulationAnswerFindFirstArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAnswerFindFirstOrThrowArgs} args - Arguments to find a SimulationAnswer
     * @example
     * // Get one SimulationAnswer
     * const simulationAnswer = await prisma.simulationAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SimulationAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimulationAnswers
     * const simulationAnswers = await prisma.simulationAnswer.findMany()
     * 
     * // Get first 10 SimulationAnswers
     * const simulationAnswers = await prisma.simulationAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationAnswerWithIdOnly = await prisma.simulationAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationAnswerFindManyArgs>(args?: SelectSubset<T, SimulationAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SimulationAnswer.
     * @param {SimulationAnswerCreateArgs} args - Arguments to create a SimulationAnswer.
     * @example
     * // Create one SimulationAnswer
     * const SimulationAnswer = await prisma.simulationAnswer.create({
     *   data: {
     *     // ... data to create a SimulationAnswer
     *   }
     * })
     * 
     */
    create<T extends SimulationAnswerCreateArgs>(args: SelectSubset<T, SimulationAnswerCreateArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SimulationAnswers.
     * @param {SimulationAnswerCreateManyArgs} args - Arguments to create many SimulationAnswers.
     * @example
     * // Create many SimulationAnswers
     * const simulationAnswer = await prisma.simulationAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationAnswerCreateManyArgs>(args?: SelectSubset<T, SimulationAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimulationAnswers and returns the data saved in the database.
     * @param {SimulationAnswerCreateManyAndReturnArgs} args - Arguments to create many SimulationAnswers.
     * @example
     * // Create many SimulationAnswers
     * const simulationAnswer = await prisma.simulationAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimulationAnswers and only return the `id`
     * const simulationAnswerWithIdOnly = await prisma.simulationAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SimulationAnswer.
     * @param {SimulationAnswerDeleteArgs} args - Arguments to delete one SimulationAnswer.
     * @example
     * // Delete one SimulationAnswer
     * const SimulationAnswer = await prisma.simulationAnswer.delete({
     *   where: {
     *     // ... filter to delete one SimulationAnswer
     *   }
     * })
     * 
     */
    delete<T extends SimulationAnswerDeleteArgs>(args: SelectSubset<T, SimulationAnswerDeleteArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SimulationAnswer.
     * @param {SimulationAnswerUpdateArgs} args - Arguments to update one SimulationAnswer.
     * @example
     * // Update one SimulationAnswer
     * const simulationAnswer = await prisma.simulationAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationAnswerUpdateArgs>(args: SelectSubset<T, SimulationAnswerUpdateArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SimulationAnswers.
     * @param {SimulationAnswerDeleteManyArgs} args - Arguments to filter SimulationAnswers to delete.
     * @example
     * // Delete a few SimulationAnswers
     * const { count } = await prisma.simulationAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationAnswerDeleteManyArgs>(args?: SelectSubset<T, SimulationAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimulationAnswers
     * const simulationAnswer = await prisma.simulationAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationAnswerUpdateManyArgs>(args: SelectSubset<T, SimulationAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationAnswers and returns the data updated in the database.
     * @param {SimulationAnswerUpdateManyAndReturnArgs} args - Arguments to update many SimulationAnswers.
     * @example
     * // Update many SimulationAnswers
     * const simulationAnswer = await prisma.simulationAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SimulationAnswers and only return the `id`
     * const simulationAnswerWithIdOnly = await prisma.simulationAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SimulationAnswer.
     * @param {SimulationAnswerUpsertArgs} args - Arguments to update or create a SimulationAnswer.
     * @example
     * // Update or create a SimulationAnswer
     * const simulationAnswer = await prisma.simulationAnswer.upsert({
     *   create: {
     *     // ... data to create a SimulationAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimulationAnswer we want to update
     *   }
     * })
     */
    upsert<T extends SimulationAnswerUpsertArgs>(args: SelectSubset<T, SimulationAnswerUpsertArgs<ExtArgs>>): Prisma__SimulationAnswerClient<$Result.GetResult<Prisma.$SimulationAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SimulationAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAnswerCountArgs} args - Arguments to filter SimulationAnswers to count.
     * @example
     * // Count the number of SimulationAnswers
     * const count = await prisma.simulationAnswer.count({
     *   where: {
     *     // ... the filter for the SimulationAnswers we want to count
     *   }
     * })
    **/
    count<T extends SimulationAnswerCountArgs>(
      args?: Subset<T, SimulationAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimulationAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationAnswerAggregateArgs>(args: Subset<T, SimulationAnswerAggregateArgs>): Prisma.PrismaPromise<GetSimulationAnswerAggregateType<T>>

    /**
     * Group by SimulationAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationAnswerGroupByArgs['orderBy'] }
        : { orderBy?: SimulationAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimulationAnswer model
   */
  readonly fields: SimulationAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimulationAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimulationAnswer model
   */
  interface SimulationAnswerFieldRefs {
    readonly id: FieldRef<"SimulationAnswer", 'String'>
    readonly simulationId: FieldRef<"SimulationAnswer", 'String'>
    readonly questionId: FieldRef<"SimulationAnswer", 'String'>
    readonly alternativeId: FieldRef<"SimulationAnswer", 'String'>
    readonly createdAt: FieldRef<"SimulationAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SimulationAnswer findUnique
   */
  export type SimulationAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SimulationAnswer to fetch.
     */
    where: SimulationAnswerWhereUniqueInput
  }

  /**
   * SimulationAnswer findUniqueOrThrow
   */
  export type SimulationAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SimulationAnswer to fetch.
     */
    where: SimulationAnswerWhereUniqueInput
  }

  /**
   * SimulationAnswer findFirst
   */
  export type SimulationAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SimulationAnswer to fetch.
     */
    where?: SimulationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationAnswers to fetch.
     */
    orderBy?: SimulationAnswerOrderByWithRelationInput | SimulationAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationAnswers.
     */
    cursor?: SimulationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationAnswers.
     */
    distinct?: SimulationAnswerScalarFieldEnum | SimulationAnswerScalarFieldEnum[]
  }

  /**
   * SimulationAnswer findFirstOrThrow
   */
  export type SimulationAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SimulationAnswer to fetch.
     */
    where?: SimulationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationAnswers to fetch.
     */
    orderBy?: SimulationAnswerOrderByWithRelationInput | SimulationAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationAnswers.
     */
    cursor?: SimulationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationAnswers.
     */
    distinct?: SimulationAnswerScalarFieldEnum | SimulationAnswerScalarFieldEnum[]
  }

  /**
   * SimulationAnswer findMany
   */
  export type SimulationAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SimulationAnswers to fetch.
     */
    where?: SimulationAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationAnswers to fetch.
     */
    orderBy?: SimulationAnswerOrderByWithRelationInput | SimulationAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimulationAnswers.
     */
    cursor?: SimulationAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationAnswers.
     */
    skip?: number
    distinct?: SimulationAnswerScalarFieldEnum | SimulationAnswerScalarFieldEnum[]
  }

  /**
   * SimulationAnswer create
   */
  export type SimulationAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a SimulationAnswer.
     */
    data: XOR<SimulationAnswerCreateInput, SimulationAnswerUncheckedCreateInput>
  }

  /**
   * SimulationAnswer createMany
   */
  export type SimulationAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimulationAnswers.
     */
    data: SimulationAnswerCreateManyInput | SimulationAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationAnswer createManyAndReturn
   */
  export type SimulationAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many SimulationAnswers.
     */
    data: SimulationAnswerCreateManyInput | SimulationAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationAnswer update
   */
  export type SimulationAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a SimulationAnswer.
     */
    data: XOR<SimulationAnswerUpdateInput, SimulationAnswerUncheckedUpdateInput>
    /**
     * Choose, which SimulationAnswer to update.
     */
    where: SimulationAnswerWhereUniqueInput
  }

  /**
   * SimulationAnswer updateMany
   */
  export type SimulationAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimulationAnswers.
     */
    data: XOR<SimulationAnswerUpdateManyMutationInput, SimulationAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SimulationAnswers to update
     */
    where?: SimulationAnswerWhereInput
    /**
     * Limit how many SimulationAnswers to update.
     */
    limit?: number
  }

  /**
   * SimulationAnswer updateManyAndReturn
   */
  export type SimulationAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * The data used to update SimulationAnswers.
     */
    data: XOR<SimulationAnswerUpdateManyMutationInput, SimulationAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SimulationAnswers to update
     */
    where?: SimulationAnswerWhereInput
    /**
     * Limit how many SimulationAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationAnswer upsert
   */
  export type SimulationAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the SimulationAnswer to update in case it exists.
     */
    where: SimulationAnswerWhereUniqueInput
    /**
     * In case the SimulationAnswer found by the `where` argument doesn't exist, create a new SimulationAnswer with this data.
     */
    create: XOR<SimulationAnswerCreateInput, SimulationAnswerUncheckedCreateInput>
    /**
     * In case the SimulationAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationAnswerUpdateInput, SimulationAnswerUncheckedUpdateInput>
  }

  /**
   * SimulationAnswer delete
   */
  export type SimulationAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
    /**
     * Filter which SimulationAnswer to delete.
     */
    where: SimulationAnswerWhereUniqueInput
  }

  /**
   * SimulationAnswer deleteMany
   */
  export type SimulationAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationAnswers to delete
     */
    where?: SimulationAnswerWhereInput
    /**
     * Limit how many SimulationAnswers to delete.
     */
    limit?: number
  }

  /**
   * SimulationAnswer without action
   */
  export type SimulationAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationAnswer
     */
    select?: SimulationAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationAnswer
     */
    omit?: SimulationAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    externalId: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    externalId: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    acronym: string | null
    sphere: string | null
    state: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    acronym: string | null
    sphere: string | null
    state: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    externalId: number
    name: number
    acronym: number
    sphere: number
    state: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    externalId?: true
  }

  export type OrganizationSumAggregateInputType = {
    externalId?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    acronym?: true
    sphere?: true
    state?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    acronym?: true
    sphere?: true
    state?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    acronym?: true
    sphere?: true
    state?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    externalId: number
    name: string
    acronym: string | null
    sphere: string | null
    state: string | null
    slug: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    acronym?: boolean
    sphere?: boolean
    state?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examRecords?: boolean | Organization$examRecordsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    acronym?: boolean
    sphere?: boolean
    state?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    acronym?: boolean
    sphere?: boolean
    state?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    externalId?: boolean
    name?: boolean
    acronym?: boolean
    sphere?: boolean
    state?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "name" | "acronym" | "sphere" | "state" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | Organization$examRecordsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      examRecords: Prisma.$ExamRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: number
      name: string
      acronym: string | null
      sphere: string | null
      state: string | null
      slug: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examRecords<T extends Organization$examRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$examRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly externalId: FieldRef<"Organization", 'Int'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly acronym: FieldRef<"Organization", 'String'>
    readonly sphere: FieldRef<"Organization", 'String'>
    readonly state: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.examRecords
   */
  export type Organization$examRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    where?: ExamRecordWhereInput
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    cursor?: ExamRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordScalarFieldEnum | ExamRecordScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Board
   */

  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardAvgAggregateOutputType = {
    externalId: number | null
  }

  export type BoardSumAggregateOutputType = {
    externalId: number | null
  }

  export type BoardMinAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    description: string | null
    acronym: string | null
    isOab: boolean | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoardMaxAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    description: string | null
    acronym: string | null
    isOab: boolean | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    externalId: number
    name: number
    description: number
    acronym: number
    isOab: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoardAvgAggregateInputType = {
    externalId?: true
  }

  export type BoardSumAggregateInputType = {
    externalId?: true
  }

  export type BoardMinAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    acronym?: true
    isOab?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    acronym?: true
    isOab?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    acronym?: true
    isOab?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithAggregationInput | BoardOrderByWithAggregationInput[]
    by: BoardScalarFieldEnum[] | BoardScalarFieldEnum
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _avg?: BoardAvgAggregateInputType
    _sum?: BoardSumAggregateInputType
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }

  export type BoardGroupByOutputType = {
    id: string
    externalId: number
    name: string
    description: string | null
    acronym: string | null
    isOab: boolean
    slug: string | null
    createdAt: Date
    updatedAt: Date
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    acronym?: boolean
    isOab?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examRecords?: boolean | Board$examRecordsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    acronym?: boolean
    isOab?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["board"]>

  export type BoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    acronym?: boolean
    isOab?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    acronym?: boolean
    isOab?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "name" | "description" | "acronym" | "isOab" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["board"]>
  export type BoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | Board$examRecordsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Board"
    objects: {
      examRecords: Prisma.$ExamRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: number
      name: string
      description: string | null
      acronym: string | null
      isOab: boolean
      slug: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["board"]>
    composites: {}
  }

  type BoardGetPayload<S extends boolean | null | undefined | BoardDefaultArgs> = $Result.GetResult<Prisma.$BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardFindUniqueArgs>(args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Board that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardFindFirstArgs>(args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardFindManyArgs>(args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
     */
    create<T extends BoardCreateArgs>(args: SelectSubset<T, BoardCreateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boards.
     * @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardCreateManyArgs>(args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boards and returns the data saved in the database.
     * @param {BoardCreateManyAndReturnArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
     */
    delete<T extends BoardDeleteArgs>(args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardUpdateArgs>(args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardDeleteManyArgs>(args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardUpdateManyArgs>(args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards and returns the data updated in the database.
     * @param {BoardUpdateManyAndReturnArgs} args - Arguments to update many Boards.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
     */
    upsert<T extends BoardUpsertArgs>(args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Board model
   */
  readonly fields: BoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examRecords<T extends Board$examRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Board$examRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Board model
   */
  interface BoardFieldRefs {
    readonly id: FieldRef<"Board", 'String'>
    readonly externalId: FieldRef<"Board", 'Int'>
    readonly name: FieldRef<"Board", 'String'>
    readonly description: FieldRef<"Board", 'String'>
    readonly acronym: FieldRef<"Board", 'String'>
    readonly isOab: FieldRef<"Board", 'Boolean'>
    readonly slug: FieldRef<"Board", 'String'>
    readonly createdAt: FieldRef<"Board", 'DateTime'>
    readonly updatedAt: FieldRef<"Board", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Board findUnique
   */
  export type BoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findFirst
   */
  export type BoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }

  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board createManyAndReturn
   */
  export type BoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board updateManyAndReturn
   */
  export type BoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }

  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to delete.
     */
    limit?: number
  }

  /**
   * Board.examRecords
   */
  export type Board$examRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    where?: ExamRecordWhereInput
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    cursor?: ExamRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordScalarFieldEnum | ExamRecordScalarFieldEnum[]
  }

  /**
   * Board without action
   */
  export type BoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    externalId: number | null
  }

  export type PositionSumAggregateOutputType = {
    externalId: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    description: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    description: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    externalId: number
    name: number
    description: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    externalId?: true
  }

  export type PositionSumAggregateInputType = {
    externalId?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: string
    externalId: number
    name: string
    description: string | null
    slug: string | null
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examRecords?: boolean | Position$examRecordsArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["position"]>

  export type PositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["position"]>

  export type PositionSelectScalar = {
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "name" | "description" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["position"]>
  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | Position$examRecordsArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      examRecords: Prisma.$ExamRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: number
      name: string
      description: string | null
      slug: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {PositionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions and returns the data updated in the database.
     * @param {PositionUpdateManyAndReturnArgs} args - Arguments to update many Positions.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PositionUpdateManyAndReturnArgs>(args: SelectSubset<T, PositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examRecords<T extends Position$examRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Position$examRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'String'>
    readonly externalId: FieldRef<"Position", 'Int'>
    readonly name: FieldRef<"Position", 'String'>
    readonly description: FieldRef<"Position", 'String'>
    readonly slug: FieldRef<"Position", 'String'>
    readonly createdAt: FieldRef<"Position", 'DateTime'>
    readonly updatedAt: FieldRef<"Position", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position createManyAndReturn
   */
  export type PositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position updateManyAndReturn
   */
  export type PositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to delete.
     */
    limit?: number
  }

  /**
   * Position.examRecords
   */
  export type Position$examRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    where?: ExamRecordWhereInput
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    cursor?: ExamRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordScalarFieldEnum | ExamRecordScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model Notice
   */

  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    externalId: number | null
  }

  export type NoticeSumAggregateOutputType = {
    externalId: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: string | null
    externalId: number | null
    slug: string | null
    enrollmentStart: Date | null
    enrollmentEnd: Date | null
    plannedApplication: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: string | null
    externalId: number | null
    slug: string | null
    enrollmentStart: Date | null
    enrollmentEnd: Date | null
    plannedApplication: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    externalId: number
    slug: number
    enrollmentStart: number
    enrollmentEnd: number
    plannedApplication: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    externalId?: true
  }

  export type NoticeSumAggregateInputType = {
    externalId?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    externalId?: true
    slug?: true
    enrollmentStart?: true
    enrollmentEnd?: true
    plannedApplication?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    externalId?: true
    slug?: true
    enrollmentStart?: true
    enrollmentEnd?: true
    plannedApplication?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    externalId?: true
    slug?: true
    enrollmentStart?: true
    enrollmentEnd?: true
    plannedApplication?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithAggregationInput | NoticeOrderByWithAggregationInput[]
    by: NoticeScalarFieldEnum[] | NoticeScalarFieldEnum
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }

  export type NoticeGroupByOutputType = {
    id: string
    externalId: number
    slug: string | null
    enrollmentStart: Date | null
    enrollmentEnd: Date | null
    plannedApplication: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    slug?: boolean
    enrollmentStart?: boolean
    enrollmentEnd?: boolean
    plannedApplication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examRecords?: boolean | Notice$examRecordsArgs<ExtArgs>
    _count?: boolean | NoticeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    slug?: boolean
    enrollmentStart?: boolean
    enrollmentEnd?: boolean
    plannedApplication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    slug?: boolean
    enrollmentStart?: boolean
    enrollmentEnd?: boolean
    plannedApplication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectScalar = {
    id?: boolean
    externalId?: boolean
    slug?: boolean
    enrollmentStart?: boolean
    enrollmentEnd?: boolean
    plannedApplication?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NoticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "slug" | "enrollmentStart" | "enrollmentEnd" | "plannedApplication" | "createdAt" | "updatedAt", ExtArgs["result"]["notice"]>
  export type NoticeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecords?: boolean | Notice$examRecordsArgs<ExtArgs>
    _count?: boolean | NoticeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NoticeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NoticeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notice"
    objects: {
      examRecords: Prisma.$ExamRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: number
      slug: string | null
      enrollmentStart: Date | null
      enrollmentEnd: Date | null
      plannedApplication: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notice"]>
    composites: {}
  }

  type NoticeGetPayload<S extends boolean | null | undefined | NoticeDefaultArgs> = $Result.GetResult<Prisma.$NoticePayload, S>

  type NoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notice'], meta: { name: 'Notice' } }
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeFindUniqueArgs>(args: SelectSubset<T, NoticeFindUniqueArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeFindFirstArgs>(args?: SelectSubset<T, NoticeFindFirstArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeFindManyArgs>(args?: SelectSubset<T, NoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
     */
    create<T extends NoticeCreateArgs>(args: SelectSubset<T, NoticeCreateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notices.
     * @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeCreateManyArgs>(args?: SelectSubset<T, NoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notices and returns the data saved in the database.
     * @param {NoticeCreateManyAndReturnArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notices and only return the `id`
     * const noticeWithIdOnly = await prisma.notice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoticeCreateManyAndReturnArgs>(args?: SelectSubset<T, NoticeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
     */
    delete<T extends NoticeDeleteArgs>(args: SelectSubset<T, NoticeDeleteArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeUpdateArgs>(args: SelectSubset<T, NoticeUpdateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeDeleteManyArgs>(args?: SelectSubset<T, NoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeUpdateManyArgs>(args: SelectSubset<T, NoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices and returns the data updated in the database.
     * @param {NoticeUpdateManyAndReturnArgs} args - Arguments to update many Notices.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notices and only return the `id`
     * const noticeWithIdOnly = await prisma.notice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoticeUpdateManyAndReturnArgs>(args: SelectSubset<T, NoticeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
     */
    upsert<T extends NoticeUpsertArgs>(args: SelectSubset<T, NoticeUpsertArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notice model
   */
  readonly fields: NoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examRecords<T extends Notice$examRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Notice$examRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notice model
   */
  interface NoticeFieldRefs {
    readonly id: FieldRef<"Notice", 'String'>
    readonly externalId: FieldRef<"Notice", 'Int'>
    readonly slug: FieldRef<"Notice", 'String'>
    readonly enrollmentStart: FieldRef<"Notice", 'DateTime'>
    readonly enrollmentEnd: FieldRef<"Notice", 'DateTime'>
    readonly plannedApplication: FieldRef<"Notice", 'DateTime'>
    readonly createdAt: FieldRef<"Notice", 'DateTime'>
    readonly updatedAt: FieldRef<"Notice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notice findUnique
   */
  export type NoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findFirst
   */
  export type NoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice create
   */
  export type NoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }

  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice createManyAndReturn
   */
  export type NoticeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice update
   */
  export type NoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
  }

  /**
   * Notice updateManyAndReturn
   */
  export type NoticeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to update.
     */
    limit?: number
  }

  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }

  /**
   * Notice delete
   */
  export type NoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
    /**
     * Limit how many Notices to delete.
     */
    limit?: number
  }

  /**
   * Notice.examRecords
   */
  export type Notice$examRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    where?: ExamRecordWhereInput
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    cursor?: ExamRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordScalarFieldEnum | ExamRecordScalarFieldEnum[]
  }

  /**
   * Notice without action
   */
  export type NoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
  }


  /**
   * Model Career
   */

  export type AggregateCareer = {
    _count: CareerCountAggregateOutputType | null
    _avg: CareerAvgAggregateOutputType | null
    _sum: CareerSumAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  export type CareerAvgAggregateOutputType = {
    externalId: number | null
  }

  export type CareerSumAggregateOutputType = {
    externalId: number | null
  }

  export type CareerMinAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareerMaxAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CareerCountAggregateOutputType = {
    id: number
    externalId: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CareerAvgAggregateInputType = {
    externalId?: true
  }

  export type CareerSumAggregateInputType = {
    externalId?: true
  }

  export type CareerMinAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareerMaxAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CareerCountAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CareerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Career to aggregate.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Careers
    **/
    _count?: true | CareerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerMaxAggregateInputType
  }

  export type GetCareerAggregateType<T extends CareerAggregateArgs> = {
        [P in keyof T & keyof AggregateCareer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareer[P]>
      : GetScalarType<T[P], AggregateCareer[P]>
  }




  export type CareerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerWhereInput
    orderBy?: CareerOrderByWithAggregationInput | CareerOrderByWithAggregationInput[]
    by: CareerScalarFieldEnum[] | CareerScalarFieldEnum
    having?: CareerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerCountAggregateInputType | true
    _avg?: CareerAvgAggregateInputType
    _sum?: CareerSumAggregateInputType
    _min?: CareerMinAggregateInputType
    _max?: CareerMaxAggregateInputType
  }

  export type CareerGroupByOutputType = {
    id: string
    externalId: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CareerCountAggregateOutputType | null
    _avg: CareerAvgAggregateOutputType | null
    _sum: CareerSumAggregateOutputType | null
    _min: CareerMinAggregateOutputType | null
    _max: CareerMaxAggregateOutputType | null
  }

  type GetCareerGroupByPayload<T extends CareerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerGroupByOutputType[P]>
            : GetScalarType<T[P], CareerGroupByOutputType[P]>
        }
      >
    >


  export type CareerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exams?: boolean | Career$examsArgs<ExtArgs>
    _count?: boolean | CareerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["career"]>

  export type CareerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["career"]>

  export type CareerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["career"]>

  export type CareerSelectScalar = {
    id?: boolean
    externalId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CareerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["career"]>
  export type CareerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | Career$examsArgs<ExtArgs>
    _count?: boolean | CareerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CareerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CareerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CareerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Career"
    objects: {
      exams: Prisma.$ExamRecordCareerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["career"]>
    composites: {}
  }

  type CareerGetPayload<S extends boolean | null | undefined | CareerDefaultArgs> = $Result.GetResult<Prisma.$CareerPayload, S>

  type CareerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CareerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CareerCountAggregateInputType | true
    }

  export interface CareerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Career'], meta: { name: 'Career' } }
    /**
     * Find zero or one Career that matches the filter.
     * @param {CareerFindUniqueArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareerFindUniqueArgs>(args: SelectSubset<T, CareerFindUniqueArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Career that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CareerFindUniqueOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareerFindUniqueOrThrowArgs>(args: SelectSubset<T, CareerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Career that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareerFindFirstArgs>(args?: SelectSubset<T, CareerFindFirstArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Career that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindFirstOrThrowArgs} args - Arguments to find a Career
     * @example
     * // Get one Career
     * const career = await prisma.career.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareerFindFirstOrThrowArgs>(args?: SelectSubset<T, CareerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Careers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Careers
     * const careers = await prisma.career.findMany()
     * 
     * // Get first 10 Careers
     * const careers = await prisma.career.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerWithIdOnly = await prisma.career.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareerFindManyArgs>(args?: SelectSubset<T, CareerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Career.
     * @param {CareerCreateArgs} args - Arguments to create a Career.
     * @example
     * // Create one Career
     * const Career = await prisma.career.create({
     *   data: {
     *     // ... data to create a Career
     *   }
     * })
     * 
     */
    create<T extends CareerCreateArgs>(args: SelectSubset<T, CareerCreateArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Careers.
     * @param {CareerCreateManyArgs} args - Arguments to create many Careers.
     * @example
     * // Create many Careers
     * const career = await prisma.career.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareerCreateManyArgs>(args?: SelectSubset<T, CareerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Careers and returns the data saved in the database.
     * @param {CareerCreateManyAndReturnArgs} args - Arguments to create many Careers.
     * @example
     * // Create many Careers
     * const career = await prisma.career.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Careers and only return the `id`
     * const careerWithIdOnly = await prisma.career.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CareerCreateManyAndReturnArgs>(args?: SelectSubset<T, CareerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Career.
     * @param {CareerDeleteArgs} args - Arguments to delete one Career.
     * @example
     * // Delete one Career
     * const Career = await prisma.career.delete({
     *   where: {
     *     // ... filter to delete one Career
     *   }
     * })
     * 
     */
    delete<T extends CareerDeleteArgs>(args: SelectSubset<T, CareerDeleteArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Career.
     * @param {CareerUpdateArgs} args - Arguments to update one Career.
     * @example
     * // Update one Career
     * const career = await prisma.career.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareerUpdateArgs>(args: SelectSubset<T, CareerUpdateArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Careers.
     * @param {CareerDeleteManyArgs} args - Arguments to filter Careers to delete.
     * @example
     * // Delete a few Careers
     * const { count } = await prisma.career.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareerDeleteManyArgs>(args?: SelectSubset<T, CareerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Careers
     * const career = await prisma.career.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareerUpdateManyArgs>(args: SelectSubset<T, CareerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Careers and returns the data updated in the database.
     * @param {CareerUpdateManyAndReturnArgs} args - Arguments to update many Careers.
     * @example
     * // Update many Careers
     * const career = await prisma.career.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Careers and only return the `id`
     * const careerWithIdOnly = await prisma.career.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CareerUpdateManyAndReturnArgs>(args: SelectSubset<T, CareerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Career.
     * @param {CareerUpsertArgs} args - Arguments to update or create a Career.
     * @example
     * // Update or create a Career
     * const career = await prisma.career.upsert({
     *   create: {
     *     // ... data to create a Career
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Career we want to update
     *   }
     * })
     */
    upsert<T extends CareerUpsertArgs>(args: SelectSubset<T, CareerUpsertArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Careers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerCountArgs} args - Arguments to filter Careers to count.
     * @example
     * // Count the number of Careers
     * const count = await prisma.career.count({
     *   where: {
     *     // ... the filter for the Careers we want to count
     *   }
     * })
    **/
    count<T extends CareerCountArgs>(
      args?: Subset<T, CareerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerAggregateArgs>(args: Subset<T, CareerAggregateArgs>): Prisma.PrismaPromise<GetCareerAggregateType<T>>

    /**
     * Group by Career.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerGroupByArgs['orderBy'] }
        : { orderBy?: CareerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Career model
   */
  readonly fields: CareerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Career.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exams<T extends Career$examsArgs<ExtArgs> = {}>(args?: Subset<T, Career$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Career model
   */
  interface CareerFieldRefs {
    readonly id: FieldRef<"Career", 'String'>
    readonly externalId: FieldRef<"Career", 'Int'>
    readonly name: FieldRef<"Career", 'String'>
    readonly description: FieldRef<"Career", 'String'>
    readonly createdAt: FieldRef<"Career", 'DateTime'>
    readonly updatedAt: FieldRef<"Career", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Career findUnique
   */
  export type CareerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career findUniqueOrThrow
   */
  export type CareerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career findFirst
   */
  export type CareerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * Career findFirstOrThrow
   */
  export type CareerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Career to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Careers.
     */
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * Career findMany
   */
  export type CareerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter, which Careers to fetch.
     */
    where?: CareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Careers to fetch.
     */
    orderBy?: CareerOrderByWithRelationInput | CareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Careers.
     */
    cursor?: CareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Careers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Careers.
     */
    skip?: number
    distinct?: CareerScalarFieldEnum | CareerScalarFieldEnum[]
  }

  /**
   * Career create
   */
  export type CareerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The data needed to create a Career.
     */
    data: XOR<CareerCreateInput, CareerUncheckedCreateInput>
  }

  /**
   * Career createMany
   */
  export type CareerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Careers.
     */
    data: CareerCreateManyInput | CareerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Career createManyAndReturn
   */
  export type CareerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * The data used to create many Careers.
     */
    data: CareerCreateManyInput | CareerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Career update
   */
  export type CareerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The data needed to update a Career.
     */
    data: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
    /**
     * Choose, which Career to update.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career updateMany
   */
  export type CareerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Careers.
     */
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyInput>
    /**
     * Filter which Careers to update
     */
    where?: CareerWhereInput
    /**
     * Limit how many Careers to update.
     */
    limit?: number
  }

  /**
   * Career updateManyAndReturn
   */
  export type CareerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * The data used to update Careers.
     */
    data: XOR<CareerUpdateManyMutationInput, CareerUncheckedUpdateManyInput>
    /**
     * Filter which Careers to update
     */
    where?: CareerWhereInput
    /**
     * Limit how many Careers to update.
     */
    limit?: number
  }

  /**
   * Career upsert
   */
  export type CareerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * The filter to search for the Career to update in case it exists.
     */
    where: CareerWhereUniqueInput
    /**
     * In case the Career found by the `where` argument doesn't exist, create a new Career with this data.
     */
    create: XOR<CareerCreateInput, CareerUncheckedCreateInput>
    /**
     * In case the Career was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerUpdateInput, CareerUncheckedUpdateInput>
  }

  /**
   * Career delete
   */
  export type CareerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
    /**
     * Filter which Career to delete.
     */
    where: CareerWhereUniqueInput
  }

  /**
   * Career deleteMany
   */
  export type CareerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Careers to delete
     */
    where?: CareerWhereInput
    /**
     * Limit how many Careers to delete.
     */
    limit?: number
  }

  /**
   * Career.exams
   */
  export type Career$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    where?: ExamRecordCareerWhereInput
    orderBy?: ExamRecordCareerOrderByWithRelationInput | ExamRecordCareerOrderByWithRelationInput[]
    cursor?: ExamRecordCareerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordCareerScalarFieldEnum | ExamRecordCareerScalarFieldEnum[]
  }

  /**
   * Career without action
   */
  export type CareerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Career
     */
    select?: CareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Career
     */
    omit?: CareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerInclude<ExtArgs> | null
  }


  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    externalId: number | null
  }

  export type AreaSumAggregateOutputType = {
    externalId: number | null
  }

  export type AreaMinAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AreaMaxAggregateOutputType = {
    id: string | null
    externalId: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    externalId: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    externalId?: true
  }

  export type AreaSumAggregateInputType = {
    externalId?: true
  }

  export type AreaMinAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    externalId?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _avg?: AreaAvgAggregateInputType
    _sum?: AreaSumAggregateInputType
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: string
    externalId: number
    name: string
    slug: string | null
    createdAt: Date
    updatedAt: Date
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exams?: boolean | Area$examsArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    externalId?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["area"]>
  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | Area$examsArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      exams: Prisma.$ExamRecordAreaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: number
      name: string
      slug: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["area"]>
    composites: {}
  }

  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaFindUniqueArgs>(args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaFindFirstArgs>(args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaFindManyArgs>(args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
     */
    create<T extends AreaCreateArgs>(args: SelectSubset<T, AreaCreateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Areas.
     * @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaCreateManyArgs>(args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {AreaCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
     */
    delete<T extends AreaDeleteArgs>(args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaUpdateArgs>(args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaDeleteManyArgs>(args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaUpdateManyArgs>(args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas and returns the data updated in the database.
     * @param {AreaUpdateManyAndReturnArgs} args - Arguments to update many Areas.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AreaUpdateManyAndReturnArgs>(args: SelectSubset<T, AreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends AreaUpsertArgs>(args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exams<T extends Area$examsArgs<ExtArgs> = {}>(args?: Subset<T, Area$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area model
   */
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'String'>
    readonly externalId: FieldRef<"Area", 'Int'>
    readonly name: FieldRef<"Area", 'String'>
    readonly slug: FieldRef<"Area", 'String'>
    readonly createdAt: FieldRef<"Area", 'DateTime'>
    readonly updatedAt: FieldRef<"Area", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area createManyAndReturn
   */
  export type AreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Area updateManyAndReturn
   */
  export type AreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to delete.
     */
    limit?: number
  }

  /**
   * Area.exams
   */
  export type Area$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    where?: ExamRecordAreaWhereInput
    orderBy?: ExamRecordAreaOrderByWithRelationInput | ExamRecordAreaOrderByWithRelationInput[]
    cursor?: ExamRecordAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordAreaScalarFieldEnum | ExamRecordAreaScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model ExamRecord
   */

  export type AggregateExamRecord = {
    _count: ExamRecordCountAggregateOutputType | null
    _avg: ExamRecordAvgAggregateOutputType | null
    _sum: ExamRecordSumAggregateOutputType | null
    _min: ExamRecordMinAggregateOutputType | null
    _max: ExamRecordMaxAggregateOutputType | null
  }

  export type ExamRecordAvgAggregateOutputType = {
    externalId: number | null
    type: number | null
    year: number | null
    questionCount: number | null
    durationMinutes: number | null
  }

  export type ExamRecordSumAggregateOutputType = {
    externalId: number | null
    type: number | null
    year: number | null
    questionCount: number | null
    durationMinutes: number | null
  }

  export type ExamRecordMinAggregateOutputType = {
    id: string | null
    externalId: number | null
    slug: string | null
    name: string | null
    type: number | null
    year: number | null
    level: string | null
    questionCount: number | null
    durationMinutes: number | null
    reviewed: boolean | null
    hasPendencies: boolean | null
    available: boolean | null
    observations: string | null
    otherData: string | null
    timestamp: Date | null
    publishedAt: Date | null
    applicationDate: Date | null
    examFileKey: string | null
    answerKeyFileKey: string | null
    organizationId: string | null
    boardId: string | null
    positionId: string | null
    noticeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamRecordMaxAggregateOutputType = {
    id: string | null
    externalId: number | null
    slug: string | null
    name: string | null
    type: number | null
    year: number | null
    level: string | null
    questionCount: number | null
    durationMinutes: number | null
    reviewed: boolean | null
    hasPendencies: boolean | null
    available: boolean | null
    observations: string | null
    otherData: string | null
    timestamp: Date | null
    publishedAt: Date | null
    applicationDate: Date | null
    examFileKey: string | null
    answerKeyFileKey: string | null
    organizationId: string | null
    boardId: string | null
    positionId: string | null
    noticeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamRecordCountAggregateOutputType = {
    id: number
    externalId: number
    slug: number
    name: number
    type: number
    year: number
    level: number
    questionCount: number
    durationMinutes: number
    reviewed: number
    hasPendencies: number
    available: number
    observations: number
    otherData: number
    timestamp: number
    publishedAt: number
    applicationDate: number
    examFileKey: number
    answerKeyFileKey: number
    organizationId: number
    boardId: number
    positionId: number
    noticeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamRecordAvgAggregateInputType = {
    externalId?: true
    type?: true
    year?: true
    questionCount?: true
    durationMinutes?: true
  }

  export type ExamRecordSumAggregateInputType = {
    externalId?: true
    type?: true
    year?: true
    questionCount?: true
    durationMinutes?: true
  }

  export type ExamRecordMinAggregateInputType = {
    id?: true
    externalId?: true
    slug?: true
    name?: true
    type?: true
    year?: true
    level?: true
    questionCount?: true
    durationMinutes?: true
    reviewed?: true
    hasPendencies?: true
    available?: true
    observations?: true
    otherData?: true
    timestamp?: true
    publishedAt?: true
    applicationDate?: true
    examFileKey?: true
    answerKeyFileKey?: true
    organizationId?: true
    boardId?: true
    positionId?: true
    noticeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamRecordMaxAggregateInputType = {
    id?: true
    externalId?: true
    slug?: true
    name?: true
    type?: true
    year?: true
    level?: true
    questionCount?: true
    durationMinutes?: true
    reviewed?: true
    hasPendencies?: true
    available?: true
    observations?: true
    otherData?: true
    timestamp?: true
    publishedAt?: true
    applicationDate?: true
    examFileKey?: true
    answerKeyFileKey?: true
    organizationId?: true
    boardId?: true
    positionId?: true
    noticeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamRecordCountAggregateInputType = {
    id?: true
    externalId?: true
    slug?: true
    name?: true
    type?: true
    year?: true
    level?: true
    questionCount?: true
    durationMinutes?: true
    reviewed?: true
    hasPendencies?: true
    available?: true
    observations?: true
    otherData?: true
    timestamp?: true
    publishedAt?: true
    applicationDate?: true
    examFileKey?: true
    answerKeyFileKey?: true
    organizationId?: true
    boardId?: true
    positionId?: true
    noticeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecord to aggregate.
     */
    where?: ExamRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecords to fetch.
     */
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamRecords
    **/
    _count?: true | ExamRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamRecordMaxAggregateInputType
  }

  export type GetExamRecordAggregateType<T extends ExamRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateExamRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamRecord[P]>
      : GetScalarType<T[P], AggregateExamRecord[P]>
  }




  export type ExamRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordWhereInput
    orderBy?: ExamRecordOrderByWithAggregationInput | ExamRecordOrderByWithAggregationInput[]
    by: ExamRecordScalarFieldEnum[] | ExamRecordScalarFieldEnum
    having?: ExamRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamRecordCountAggregateInputType | true
    _avg?: ExamRecordAvgAggregateInputType
    _sum?: ExamRecordSumAggregateInputType
    _min?: ExamRecordMinAggregateInputType
    _max?: ExamRecordMaxAggregateInputType
  }

  export type ExamRecordGroupByOutputType = {
    id: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes: number | null
    reviewed: boolean
    hasPendencies: boolean
    available: boolean
    observations: string | null
    otherData: string | null
    timestamp: Date | null
    publishedAt: Date | null
    applicationDate: Date | null
    examFileKey: string | null
    answerKeyFileKey: string | null
    organizationId: string
    boardId: string
    positionId: string
    noticeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExamRecordCountAggregateOutputType | null
    _avg: ExamRecordAvgAggregateOutputType | null
    _sum: ExamRecordSumAggregateOutputType | null
    _min: ExamRecordMinAggregateOutputType | null
    _max: ExamRecordMaxAggregateOutputType | null
  }

  type GetExamRecordGroupByPayload<T extends ExamRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ExamRecordGroupByOutputType[P]>
        }
      >
    >


  export type ExamRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    slug?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    level?: boolean
    questionCount?: boolean
    durationMinutes?: boolean
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: boolean
    otherData?: boolean
    timestamp?: boolean
    publishedAt?: boolean
    applicationDate?: boolean
    examFileKey?: boolean
    answerKeyFileKey?: boolean
    organizationId?: boolean
    boardId?: boolean
    positionId?: boolean
    noticeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    notice?: boolean | ExamRecord$noticeArgs<ExtArgs>
    careers?: boolean | ExamRecord$careersArgs<ExtArgs>
    areas?: boolean | ExamRecord$areasArgs<ExtArgs>
    parts?: boolean | ExamRecord$partsArgs<ExtArgs>
    _count?: boolean | ExamRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecord"]>

  export type ExamRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    slug?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    level?: boolean
    questionCount?: boolean
    durationMinutes?: boolean
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: boolean
    otherData?: boolean
    timestamp?: boolean
    publishedAt?: boolean
    applicationDate?: boolean
    examFileKey?: boolean
    answerKeyFileKey?: boolean
    organizationId?: boolean
    boardId?: boolean
    positionId?: boolean
    noticeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    notice?: boolean | ExamRecord$noticeArgs<ExtArgs>
  }, ExtArgs["result"]["examRecord"]>

  export type ExamRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    slug?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    level?: boolean
    questionCount?: boolean
    durationMinutes?: boolean
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: boolean
    otherData?: boolean
    timestamp?: boolean
    publishedAt?: boolean
    applicationDate?: boolean
    examFileKey?: boolean
    answerKeyFileKey?: boolean
    organizationId?: boolean
    boardId?: boolean
    positionId?: boolean
    noticeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    notice?: boolean | ExamRecord$noticeArgs<ExtArgs>
  }, ExtArgs["result"]["examRecord"]>

  export type ExamRecordSelectScalar = {
    id?: boolean
    externalId?: boolean
    slug?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    level?: boolean
    questionCount?: boolean
    durationMinutes?: boolean
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: boolean
    otherData?: boolean
    timestamp?: boolean
    publishedAt?: boolean
    applicationDate?: boolean
    examFileKey?: boolean
    answerKeyFileKey?: boolean
    organizationId?: boolean
    boardId?: boolean
    positionId?: boolean
    noticeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "slug" | "name" | "type" | "year" | "level" | "questionCount" | "durationMinutes" | "reviewed" | "hasPendencies" | "available" | "observations" | "otherData" | "timestamp" | "publishedAt" | "applicationDate" | "examFileKey" | "answerKeyFileKey" | "organizationId" | "boardId" | "positionId" | "noticeId" | "createdAt" | "updatedAt", ExtArgs["result"]["examRecord"]>
  export type ExamRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    notice?: boolean | ExamRecord$noticeArgs<ExtArgs>
    careers?: boolean | ExamRecord$careersArgs<ExtArgs>
    areas?: boolean | ExamRecord$areasArgs<ExtArgs>
    parts?: boolean | ExamRecord$partsArgs<ExtArgs>
    _count?: boolean | ExamRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    notice?: boolean | ExamRecord$noticeArgs<ExtArgs>
  }
  export type ExamRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    board?: boolean | BoardDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    notice?: boolean | ExamRecord$noticeArgs<ExtArgs>
  }

  export type $ExamRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamRecord"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      board: Prisma.$BoardPayload<ExtArgs>
      position: Prisma.$PositionPayload<ExtArgs>
      notice: Prisma.$NoticePayload<ExtArgs> | null
      careers: Prisma.$ExamRecordCareerPayload<ExtArgs>[]
      areas: Prisma.$ExamRecordAreaPayload<ExtArgs>[]
      parts: Prisma.$ExamRecordPartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: number
      slug: string
      name: string
      type: number
      year: number
      level: string
      questionCount: number
      durationMinutes: number | null
      reviewed: boolean
      hasPendencies: boolean
      available: boolean
      observations: string | null
      otherData: string | null
      timestamp: Date | null
      publishedAt: Date | null
      applicationDate: Date | null
      examFileKey: string | null
      answerKeyFileKey: string | null
      organizationId: string
      boardId: string
      positionId: string
      noticeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examRecord"]>
    composites: {}
  }

  type ExamRecordGetPayload<S extends boolean | null | undefined | ExamRecordDefaultArgs> = $Result.GetResult<Prisma.$ExamRecordPayload, S>

  type ExamRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamRecordCountAggregateInputType | true
    }

  export interface ExamRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamRecord'], meta: { name: 'ExamRecord' } }
    /**
     * Find zero or one ExamRecord that matches the filter.
     * @param {ExamRecordFindUniqueArgs} args - Arguments to find a ExamRecord
     * @example
     * // Get one ExamRecord
     * const examRecord = await prisma.examRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamRecordFindUniqueArgs>(args: SelectSubset<T, ExamRecordFindUniqueArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamRecordFindUniqueOrThrowArgs} args - Arguments to find a ExamRecord
     * @example
     * // Get one ExamRecord
     * const examRecord = await prisma.examRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordFindFirstArgs} args - Arguments to find a ExamRecord
     * @example
     * // Get one ExamRecord
     * const examRecord = await prisma.examRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamRecordFindFirstArgs>(args?: SelectSubset<T, ExamRecordFindFirstArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordFindFirstOrThrowArgs} args - Arguments to find a ExamRecord
     * @example
     * // Get one ExamRecord
     * const examRecord = await prisma.examRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamRecords
     * const examRecords = await prisma.examRecord.findMany()
     * 
     * // Get first 10 ExamRecords
     * const examRecords = await prisma.examRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examRecordWithIdOnly = await prisma.examRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamRecordFindManyArgs>(args?: SelectSubset<T, ExamRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamRecord.
     * @param {ExamRecordCreateArgs} args - Arguments to create a ExamRecord.
     * @example
     * // Create one ExamRecord
     * const ExamRecord = await prisma.examRecord.create({
     *   data: {
     *     // ... data to create a ExamRecord
     *   }
     * })
     * 
     */
    create<T extends ExamRecordCreateArgs>(args: SelectSubset<T, ExamRecordCreateArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamRecords.
     * @param {ExamRecordCreateManyArgs} args - Arguments to create many ExamRecords.
     * @example
     * // Create many ExamRecords
     * const examRecord = await prisma.examRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamRecordCreateManyArgs>(args?: SelectSubset<T, ExamRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamRecords and returns the data saved in the database.
     * @param {ExamRecordCreateManyAndReturnArgs} args - Arguments to create many ExamRecords.
     * @example
     * // Create many ExamRecords
     * const examRecord = await prisma.examRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamRecords and only return the `id`
     * const examRecordWithIdOnly = await prisma.examRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamRecord.
     * @param {ExamRecordDeleteArgs} args - Arguments to delete one ExamRecord.
     * @example
     * // Delete one ExamRecord
     * const ExamRecord = await prisma.examRecord.delete({
     *   where: {
     *     // ... filter to delete one ExamRecord
     *   }
     * })
     * 
     */
    delete<T extends ExamRecordDeleteArgs>(args: SelectSubset<T, ExamRecordDeleteArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamRecord.
     * @param {ExamRecordUpdateArgs} args - Arguments to update one ExamRecord.
     * @example
     * // Update one ExamRecord
     * const examRecord = await prisma.examRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamRecordUpdateArgs>(args: SelectSubset<T, ExamRecordUpdateArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamRecords.
     * @param {ExamRecordDeleteManyArgs} args - Arguments to filter ExamRecords to delete.
     * @example
     * // Delete a few ExamRecords
     * const { count } = await prisma.examRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamRecordDeleteManyArgs>(args?: SelectSubset<T, ExamRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamRecords
     * const examRecord = await prisma.examRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamRecordUpdateManyArgs>(args: SelectSubset<T, ExamRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecords and returns the data updated in the database.
     * @param {ExamRecordUpdateManyAndReturnArgs} args - Arguments to update many ExamRecords.
     * @example
     * // Update many ExamRecords
     * const examRecord = await prisma.examRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamRecords and only return the `id`
     * const examRecordWithIdOnly = await prisma.examRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamRecord.
     * @param {ExamRecordUpsertArgs} args - Arguments to update or create a ExamRecord.
     * @example
     * // Update or create a ExamRecord
     * const examRecord = await prisma.examRecord.upsert({
     *   create: {
     *     // ... data to create a ExamRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamRecord we want to update
     *   }
     * })
     */
    upsert<T extends ExamRecordUpsertArgs>(args: SelectSubset<T, ExamRecordUpsertArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCountArgs} args - Arguments to filter ExamRecords to count.
     * @example
     * // Count the number of ExamRecords
     * const count = await prisma.examRecord.count({
     *   where: {
     *     // ... the filter for the ExamRecords we want to count
     *   }
     * })
    **/
    count<T extends ExamRecordCountArgs>(
      args?: Subset<T, ExamRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamRecordAggregateArgs>(args: Subset<T, ExamRecordAggregateArgs>): Prisma.PrismaPromise<GetExamRecordAggregateType<T>>

    /**
     * Group by ExamRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamRecordGroupByArgs['orderBy'] }
        : { orderBy?: ExamRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamRecord model
   */
  readonly fields: ExamRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    position<T extends PositionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PositionDefaultArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notice<T extends ExamRecord$noticeArgs<ExtArgs> = {}>(args?: Subset<T, ExamRecord$noticeArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    careers<T extends ExamRecord$careersArgs<ExtArgs> = {}>(args?: Subset<T, ExamRecord$careersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    areas<T extends ExamRecord$areasArgs<ExtArgs> = {}>(args?: Subset<T, ExamRecord$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parts<T extends ExamRecord$partsArgs<ExtArgs> = {}>(args?: Subset<T, ExamRecord$partsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamRecord model
   */
  interface ExamRecordFieldRefs {
    readonly id: FieldRef<"ExamRecord", 'String'>
    readonly externalId: FieldRef<"ExamRecord", 'Int'>
    readonly slug: FieldRef<"ExamRecord", 'String'>
    readonly name: FieldRef<"ExamRecord", 'String'>
    readonly type: FieldRef<"ExamRecord", 'Int'>
    readonly year: FieldRef<"ExamRecord", 'Int'>
    readonly level: FieldRef<"ExamRecord", 'String'>
    readonly questionCount: FieldRef<"ExamRecord", 'Int'>
    readonly durationMinutes: FieldRef<"ExamRecord", 'Int'>
    readonly reviewed: FieldRef<"ExamRecord", 'Boolean'>
    readonly hasPendencies: FieldRef<"ExamRecord", 'Boolean'>
    readonly available: FieldRef<"ExamRecord", 'Boolean'>
    readonly observations: FieldRef<"ExamRecord", 'String'>
    readonly otherData: FieldRef<"ExamRecord", 'String'>
    readonly timestamp: FieldRef<"ExamRecord", 'DateTime'>
    readonly publishedAt: FieldRef<"ExamRecord", 'DateTime'>
    readonly applicationDate: FieldRef<"ExamRecord", 'DateTime'>
    readonly examFileKey: FieldRef<"ExamRecord", 'String'>
    readonly answerKeyFileKey: FieldRef<"ExamRecord", 'String'>
    readonly organizationId: FieldRef<"ExamRecord", 'String'>
    readonly boardId: FieldRef<"ExamRecord", 'String'>
    readonly positionId: FieldRef<"ExamRecord", 'String'>
    readonly noticeId: FieldRef<"ExamRecord", 'String'>
    readonly createdAt: FieldRef<"ExamRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamRecord findUnique
   */
  export type ExamRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecord to fetch.
     */
    where: ExamRecordWhereUniqueInput
  }

  /**
   * ExamRecord findUniqueOrThrow
   */
  export type ExamRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecord to fetch.
     */
    where: ExamRecordWhereUniqueInput
  }

  /**
   * ExamRecord findFirst
   */
  export type ExamRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecord to fetch.
     */
    where?: ExamRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecords to fetch.
     */
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecords.
     */
    cursor?: ExamRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecords.
     */
    distinct?: ExamRecordScalarFieldEnum | ExamRecordScalarFieldEnum[]
  }

  /**
   * ExamRecord findFirstOrThrow
   */
  export type ExamRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecord to fetch.
     */
    where?: ExamRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecords to fetch.
     */
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecords.
     */
    cursor?: ExamRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecords.
     */
    distinct?: ExamRecordScalarFieldEnum | ExamRecordScalarFieldEnum[]
  }

  /**
   * ExamRecord findMany
   */
  export type ExamRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecords to fetch.
     */
    where?: ExamRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecords to fetch.
     */
    orderBy?: ExamRecordOrderByWithRelationInput | ExamRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamRecords.
     */
    cursor?: ExamRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecords.
     */
    skip?: number
    distinct?: ExamRecordScalarFieldEnum | ExamRecordScalarFieldEnum[]
  }

  /**
   * ExamRecord create
   */
  export type ExamRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamRecord.
     */
    data: XOR<ExamRecordCreateInput, ExamRecordUncheckedCreateInput>
  }

  /**
   * ExamRecord createMany
   */
  export type ExamRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamRecords.
     */
    data: ExamRecordCreateManyInput | ExamRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamRecord createManyAndReturn
   */
  export type ExamRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * The data used to create many ExamRecords.
     */
    data: ExamRecordCreateManyInput | ExamRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecord update
   */
  export type ExamRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamRecord.
     */
    data: XOR<ExamRecordUpdateInput, ExamRecordUncheckedUpdateInput>
    /**
     * Choose, which ExamRecord to update.
     */
    where: ExamRecordWhereUniqueInput
  }

  /**
   * ExamRecord updateMany
   */
  export type ExamRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamRecords.
     */
    data: XOR<ExamRecordUpdateManyMutationInput, ExamRecordUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecords to update
     */
    where?: ExamRecordWhereInput
    /**
     * Limit how many ExamRecords to update.
     */
    limit?: number
  }

  /**
   * ExamRecord updateManyAndReturn
   */
  export type ExamRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * The data used to update ExamRecords.
     */
    data: XOR<ExamRecordUpdateManyMutationInput, ExamRecordUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecords to update
     */
    where?: ExamRecordWhereInput
    /**
     * Limit how many ExamRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecord upsert
   */
  export type ExamRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamRecord to update in case it exists.
     */
    where: ExamRecordWhereUniqueInput
    /**
     * In case the ExamRecord found by the `where` argument doesn't exist, create a new ExamRecord with this data.
     */
    create: XOR<ExamRecordCreateInput, ExamRecordUncheckedCreateInput>
    /**
     * In case the ExamRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamRecordUpdateInput, ExamRecordUncheckedUpdateInput>
  }

  /**
   * ExamRecord delete
   */
  export type ExamRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
    /**
     * Filter which ExamRecord to delete.
     */
    where: ExamRecordWhereUniqueInput
  }

  /**
   * ExamRecord deleteMany
   */
  export type ExamRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecords to delete
     */
    where?: ExamRecordWhereInput
    /**
     * Limit how many ExamRecords to delete.
     */
    limit?: number
  }

  /**
   * ExamRecord.notice
   */
  export type ExamRecord$noticeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notice
     */
    omit?: NoticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoticeInclude<ExtArgs> | null
    where?: NoticeWhereInput
  }

  /**
   * ExamRecord.careers
   */
  export type ExamRecord$careersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    where?: ExamRecordCareerWhereInput
    orderBy?: ExamRecordCareerOrderByWithRelationInput | ExamRecordCareerOrderByWithRelationInput[]
    cursor?: ExamRecordCareerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordCareerScalarFieldEnum | ExamRecordCareerScalarFieldEnum[]
  }

  /**
   * ExamRecord.areas
   */
  export type ExamRecord$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    where?: ExamRecordAreaWhereInput
    orderBy?: ExamRecordAreaOrderByWithRelationInput | ExamRecordAreaOrderByWithRelationInput[]
    cursor?: ExamRecordAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordAreaScalarFieldEnum | ExamRecordAreaScalarFieldEnum[]
  }

  /**
   * ExamRecord.parts
   */
  export type ExamRecord$partsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    where?: ExamRecordPartWhereInput
    orderBy?: ExamRecordPartOrderByWithRelationInput | ExamRecordPartOrderByWithRelationInput[]
    cursor?: ExamRecordPartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamRecordPartScalarFieldEnum | ExamRecordPartScalarFieldEnum[]
  }

  /**
   * ExamRecord without action
   */
  export type ExamRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecord
     */
    select?: ExamRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecord
     */
    omit?: ExamRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordInclude<ExtArgs> | null
  }


  /**
   * Model ExamRecordCareer
   */

  export type AggregateExamRecordCareer = {
    _count: ExamRecordCareerCountAggregateOutputType | null
    _min: ExamRecordCareerMinAggregateOutputType | null
    _max: ExamRecordCareerMaxAggregateOutputType | null
  }

  export type ExamRecordCareerMinAggregateOutputType = {
    id: string | null
    examRecordId: string | null
    careerId: string | null
  }

  export type ExamRecordCareerMaxAggregateOutputType = {
    id: string | null
    examRecordId: string | null
    careerId: string | null
  }

  export type ExamRecordCareerCountAggregateOutputType = {
    id: number
    examRecordId: number
    careerId: number
    _all: number
  }


  export type ExamRecordCareerMinAggregateInputType = {
    id?: true
    examRecordId?: true
    careerId?: true
  }

  export type ExamRecordCareerMaxAggregateInputType = {
    id?: true
    examRecordId?: true
    careerId?: true
  }

  export type ExamRecordCareerCountAggregateInputType = {
    id?: true
    examRecordId?: true
    careerId?: true
    _all?: true
  }

  export type ExamRecordCareerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecordCareer to aggregate.
     */
    where?: ExamRecordCareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordCareers to fetch.
     */
    orderBy?: ExamRecordCareerOrderByWithRelationInput | ExamRecordCareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamRecordCareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordCareers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordCareers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamRecordCareers
    **/
    _count?: true | ExamRecordCareerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamRecordCareerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamRecordCareerMaxAggregateInputType
  }

  export type GetExamRecordCareerAggregateType<T extends ExamRecordCareerAggregateArgs> = {
        [P in keyof T & keyof AggregateExamRecordCareer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamRecordCareer[P]>
      : GetScalarType<T[P], AggregateExamRecordCareer[P]>
  }




  export type ExamRecordCareerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordCareerWhereInput
    orderBy?: ExamRecordCareerOrderByWithAggregationInput | ExamRecordCareerOrderByWithAggregationInput[]
    by: ExamRecordCareerScalarFieldEnum[] | ExamRecordCareerScalarFieldEnum
    having?: ExamRecordCareerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamRecordCareerCountAggregateInputType | true
    _min?: ExamRecordCareerMinAggregateInputType
    _max?: ExamRecordCareerMaxAggregateInputType
  }

  export type ExamRecordCareerGroupByOutputType = {
    id: string
    examRecordId: string
    careerId: string
    _count: ExamRecordCareerCountAggregateOutputType | null
    _min: ExamRecordCareerMinAggregateOutputType | null
    _max: ExamRecordCareerMaxAggregateOutputType | null
  }

  type GetExamRecordCareerGroupByPayload<T extends ExamRecordCareerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamRecordCareerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamRecordCareerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamRecordCareerGroupByOutputType[P]>
            : GetScalarType<T[P], ExamRecordCareerGroupByOutputType[P]>
        }
      >
    >


  export type ExamRecordCareerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    careerId?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordCareer"]>

  export type ExamRecordCareerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    careerId?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordCareer"]>

  export type ExamRecordCareerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    careerId?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordCareer"]>

  export type ExamRecordCareerSelectScalar = {
    id?: boolean
    examRecordId?: boolean
    careerId?: boolean
  }

  export type ExamRecordCareerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examRecordId" | "careerId", ExtArgs["result"]["examRecordCareer"]>
  export type ExamRecordCareerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }
  export type ExamRecordCareerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }
  export type ExamRecordCareerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    career?: boolean | CareerDefaultArgs<ExtArgs>
  }

  export type $ExamRecordCareerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamRecordCareer"
    objects: {
      examRecord: Prisma.$ExamRecordPayload<ExtArgs>
      career: Prisma.$CareerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examRecordId: string
      careerId: string
    }, ExtArgs["result"]["examRecordCareer"]>
    composites: {}
  }

  type ExamRecordCareerGetPayload<S extends boolean | null | undefined | ExamRecordCareerDefaultArgs> = $Result.GetResult<Prisma.$ExamRecordCareerPayload, S>

  type ExamRecordCareerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamRecordCareerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamRecordCareerCountAggregateInputType | true
    }

  export interface ExamRecordCareerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamRecordCareer'], meta: { name: 'ExamRecordCareer' } }
    /**
     * Find zero or one ExamRecordCareer that matches the filter.
     * @param {ExamRecordCareerFindUniqueArgs} args - Arguments to find a ExamRecordCareer
     * @example
     * // Get one ExamRecordCareer
     * const examRecordCareer = await prisma.examRecordCareer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamRecordCareerFindUniqueArgs>(args: SelectSubset<T, ExamRecordCareerFindUniqueArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamRecordCareer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamRecordCareerFindUniqueOrThrowArgs} args - Arguments to find a ExamRecordCareer
     * @example
     * // Get one ExamRecordCareer
     * const examRecordCareer = await prisma.examRecordCareer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamRecordCareerFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamRecordCareerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecordCareer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCareerFindFirstArgs} args - Arguments to find a ExamRecordCareer
     * @example
     * // Get one ExamRecordCareer
     * const examRecordCareer = await prisma.examRecordCareer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamRecordCareerFindFirstArgs>(args?: SelectSubset<T, ExamRecordCareerFindFirstArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecordCareer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCareerFindFirstOrThrowArgs} args - Arguments to find a ExamRecordCareer
     * @example
     * // Get one ExamRecordCareer
     * const examRecordCareer = await prisma.examRecordCareer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamRecordCareerFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamRecordCareerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamRecordCareers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCareerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamRecordCareers
     * const examRecordCareers = await prisma.examRecordCareer.findMany()
     * 
     * // Get first 10 ExamRecordCareers
     * const examRecordCareers = await prisma.examRecordCareer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examRecordCareerWithIdOnly = await prisma.examRecordCareer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamRecordCareerFindManyArgs>(args?: SelectSubset<T, ExamRecordCareerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamRecordCareer.
     * @param {ExamRecordCareerCreateArgs} args - Arguments to create a ExamRecordCareer.
     * @example
     * // Create one ExamRecordCareer
     * const ExamRecordCareer = await prisma.examRecordCareer.create({
     *   data: {
     *     // ... data to create a ExamRecordCareer
     *   }
     * })
     * 
     */
    create<T extends ExamRecordCareerCreateArgs>(args: SelectSubset<T, ExamRecordCareerCreateArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamRecordCareers.
     * @param {ExamRecordCareerCreateManyArgs} args - Arguments to create many ExamRecordCareers.
     * @example
     * // Create many ExamRecordCareers
     * const examRecordCareer = await prisma.examRecordCareer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamRecordCareerCreateManyArgs>(args?: SelectSubset<T, ExamRecordCareerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamRecordCareers and returns the data saved in the database.
     * @param {ExamRecordCareerCreateManyAndReturnArgs} args - Arguments to create many ExamRecordCareers.
     * @example
     * // Create many ExamRecordCareers
     * const examRecordCareer = await prisma.examRecordCareer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamRecordCareers and only return the `id`
     * const examRecordCareerWithIdOnly = await prisma.examRecordCareer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamRecordCareerCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamRecordCareerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamRecordCareer.
     * @param {ExamRecordCareerDeleteArgs} args - Arguments to delete one ExamRecordCareer.
     * @example
     * // Delete one ExamRecordCareer
     * const ExamRecordCareer = await prisma.examRecordCareer.delete({
     *   where: {
     *     // ... filter to delete one ExamRecordCareer
     *   }
     * })
     * 
     */
    delete<T extends ExamRecordCareerDeleteArgs>(args: SelectSubset<T, ExamRecordCareerDeleteArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamRecordCareer.
     * @param {ExamRecordCareerUpdateArgs} args - Arguments to update one ExamRecordCareer.
     * @example
     * // Update one ExamRecordCareer
     * const examRecordCareer = await prisma.examRecordCareer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamRecordCareerUpdateArgs>(args: SelectSubset<T, ExamRecordCareerUpdateArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamRecordCareers.
     * @param {ExamRecordCareerDeleteManyArgs} args - Arguments to filter ExamRecordCareers to delete.
     * @example
     * // Delete a few ExamRecordCareers
     * const { count } = await prisma.examRecordCareer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamRecordCareerDeleteManyArgs>(args?: SelectSubset<T, ExamRecordCareerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecordCareers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCareerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamRecordCareers
     * const examRecordCareer = await prisma.examRecordCareer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamRecordCareerUpdateManyArgs>(args: SelectSubset<T, ExamRecordCareerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecordCareers and returns the data updated in the database.
     * @param {ExamRecordCareerUpdateManyAndReturnArgs} args - Arguments to update many ExamRecordCareers.
     * @example
     * // Update many ExamRecordCareers
     * const examRecordCareer = await prisma.examRecordCareer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamRecordCareers and only return the `id`
     * const examRecordCareerWithIdOnly = await prisma.examRecordCareer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamRecordCareerUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamRecordCareerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamRecordCareer.
     * @param {ExamRecordCareerUpsertArgs} args - Arguments to update or create a ExamRecordCareer.
     * @example
     * // Update or create a ExamRecordCareer
     * const examRecordCareer = await prisma.examRecordCareer.upsert({
     *   create: {
     *     // ... data to create a ExamRecordCareer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamRecordCareer we want to update
     *   }
     * })
     */
    upsert<T extends ExamRecordCareerUpsertArgs>(args: SelectSubset<T, ExamRecordCareerUpsertArgs<ExtArgs>>): Prisma__ExamRecordCareerClient<$Result.GetResult<Prisma.$ExamRecordCareerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamRecordCareers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCareerCountArgs} args - Arguments to filter ExamRecordCareers to count.
     * @example
     * // Count the number of ExamRecordCareers
     * const count = await prisma.examRecordCareer.count({
     *   where: {
     *     // ... the filter for the ExamRecordCareers we want to count
     *   }
     * })
    **/
    count<T extends ExamRecordCareerCountArgs>(
      args?: Subset<T, ExamRecordCareerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamRecordCareerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamRecordCareer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCareerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamRecordCareerAggregateArgs>(args: Subset<T, ExamRecordCareerAggregateArgs>): Prisma.PrismaPromise<GetExamRecordCareerAggregateType<T>>

    /**
     * Group by ExamRecordCareer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordCareerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamRecordCareerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamRecordCareerGroupByArgs['orderBy'] }
        : { orderBy?: ExamRecordCareerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamRecordCareerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamRecordCareerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamRecordCareer model
   */
  readonly fields: ExamRecordCareerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamRecordCareer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamRecordCareerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examRecord<T extends ExamRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamRecordDefaultArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    career<T extends CareerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CareerDefaultArgs<ExtArgs>>): Prisma__CareerClient<$Result.GetResult<Prisma.$CareerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamRecordCareer model
   */
  interface ExamRecordCareerFieldRefs {
    readonly id: FieldRef<"ExamRecordCareer", 'String'>
    readonly examRecordId: FieldRef<"ExamRecordCareer", 'String'>
    readonly careerId: FieldRef<"ExamRecordCareer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExamRecordCareer findUnique
   */
  export type ExamRecordCareerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordCareer to fetch.
     */
    where: ExamRecordCareerWhereUniqueInput
  }

  /**
   * ExamRecordCareer findUniqueOrThrow
   */
  export type ExamRecordCareerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordCareer to fetch.
     */
    where: ExamRecordCareerWhereUniqueInput
  }

  /**
   * ExamRecordCareer findFirst
   */
  export type ExamRecordCareerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordCareer to fetch.
     */
    where?: ExamRecordCareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordCareers to fetch.
     */
    orderBy?: ExamRecordCareerOrderByWithRelationInput | ExamRecordCareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecordCareers.
     */
    cursor?: ExamRecordCareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordCareers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordCareers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecordCareers.
     */
    distinct?: ExamRecordCareerScalarFieldEnum | ExamRecordCareerScalarFieldEnum[]
  }

  /**
   * ExamRecordCareer findFirstOrThrow
   */
  export type ExamRecordCareerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordCareer to fetch.
     */
    where?: ExamRecordCareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordCareers to fetch.
     */
    orderBy?: ExamRecordCareerOrderByWithRelationInput | ExamRecordCareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecordCareers.
     */
    cursor?: ExamRecordCareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordCareers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordCareers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecordCareers.
     */
    distinct?: ExamRecordCareerScalarFieldEnum | ExamRecordCareerScalarFieldEnum[]
  }

  /**
   * ExamRecordCareer findMany
   */
  export type ExamRecordCareerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordCareers to fetch.
     */
    where?: ExamRecordCareerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordCareers to fetch.
     */
    orderBy?: ExamRecordCareerOrderByWithRelationInput | ExamRecordCareerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamRecordCareers.
     */
    cursor?: ExamRecordCareerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordCareers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordCareers.
     */
    skip?: number
    distinct?: ExamRecordCareerScalarFieldEnum | ExamRecordCareerScalarFieldEnum[]
  }

  /**
   * ExamRecordCareer create
   */
  export type ExamRecordCareerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamRecordCareer.
     */
    data: XOR<ExamRecordCareerCreateInput, ExamRecordCareerUncheckedCreateInput>
  }

  /**
   * ExamRecordCareer createMany
   */
  export type ExamRecordCareerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamRecordCareers.
     */
    data: ExamRecordCareerCreateManyInput | ExamRecordCareerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamRecordCareer createManyAndReturn
   */
  export type ExamRecordCareerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * The data used to create many ExamRecordCareers.
     */
    data: ExamRecordCareerCreateManyInput | ExamRecordCareerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecordCareer update
   */
  export type ExamRecordCareerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamRecordCareer.
     */
    data: XOR<ExamRecordCareerUpdateInput, ExamRecordCareerUncheckedUpdateInput>
    /**
     * Choose, which ExamRecordCareer to update.
     */
    where: ExamRecordCareerWhereUniqueInput
  }

  /**
   * ExamRecordCareer updateMany
   */
  export type ExamRecordCareerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamRecordCareers.
     */
    data: XOR<ExamRecordCareerUpdateManyMutationInput, ExamRecordCareerUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecordCareers to update
     */
    where?: ExamRecordCareerWhereInput
    /**
     * Limit how many ExamRecordCareers to update.
     */
    limit?: number
  }

  /**
   * ExamRecordCareer updateManyAndReturn
   */
  export type ExamRecordCareerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * The data used to update ExamRecordCareers.
     */
    data: XOR<ExamRecordCareerUpdateManyMutationInput, ExamRecordCareerUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecordCareers to update
     */
    where?: ExamRecordCareerWhereInput
    /**
     * Limit how many ExamRecordCareers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecordCareer upsert
   */
  export type ExamRecordCareerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamRecordCareer to update in case it exists.
     */
    where: ExamRecordCareerWhereUniqueInput
    /**
     * In case the ExamRecordCareer found by the `where` argument doesn't exist, create a new ExamRecordCareer with this data.
     */
    create: XOR<ExamRecordCareerCreateInput, ExamRecordCareerUncheckedCreateInput>
    /**
     * In case the ExamRecordCareer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamRecordCareerUpdateInput, ExamRecordCareerUncheckedUpdateInput>
  }

  /**
   * ExamRecordCareer delete
   */
  export type ExamRecordCareerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
    /**
     * Filter which ExamRecordCareer to delete.
     */
    where: ExamRecordCareerWhereUniqueInput
  }

  /**
   * ExamRecordCareer deleteMany
   */
  export type ExamRecordCareerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecordCareers to delete
     */
    where?: ExamRecordCareerWhereInput
    /**
     * Limit how many ExamRecordCareers to delete.
     */
    limit?: number
  }

  /**
   * ExamRecordCareer without action
   */
  export type ExamRecordCareerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordCareer
     */
    select?: ExamRecordCareerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordCareer
     */
    omit?: ExamRecordCareerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordCareerInclude<ExtArgs> | null
  }


  /**
   * Model ExamRecordArea
   */

  export type AggregateExamRecordArea = {
    _count: ExamRecordAreaCountAggregateOutputType | null
    _min: ExamRecordAreaMinAggregateOutputType | null
    _max: ExamRecordAreaMaxAggregateOutputType | null
  }

  export type ExamRecordAreaMinAggregateOutputType = {
    id: string | null
    examRecordId: string | null
    areaId: string | null
  }

  export type ExamRecordAreaMaxAggregateOutputType = {
    id: string | null
    examRecordId: string | null
    areaId: string | null
  }

  export type ExamRecordAreaCountAggregateOutputType = {
    id: number
    examRecordId: number
    areaId: number
    _all: number
  }


  export type ExamRecordAreaMinAggregateInputType = {
    id?: true
    examRecordId?: true
    areaId?: true
  }

  export type ExamRecordAreaMaxAggregateInputType = {
    id?: true
    examRecordId?: true
    areaId?: true
  }

  export type ExamRecordAreaCountAggregateInputType = {
    id?: true
    examRecordId?: true
    areaId?: true
    _all?: true
  }

  export type ExamRecordAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecordArea to aggregate.
     */
    where?: ExamRecordAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordAreas to fetch.
     */
    orderBy?: ExamRecordAreaOrderByWithRelationInput | ExamRecordAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamRecordAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamRecordAreas
    **/
    _count?: true | ExamRecordAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamRecordAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamRecordAreaMaxAggregateInputType
  }

  export type GetExamRecordAreaAggregateType<T extends ExamRecordAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateExamRecordArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamRecordArea[P]>
      : GetScalarType<T[P], AggregateExamRecordArea[P]>
  }




  export type ExamRecordAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordAreaWhereInput
    orderBy?: ExamRecordAreaOrderByWithAggregationInput | ExamRecordAreaOrderByWithAggregationInput[]
    by: ExamRecordAreaScalarFieldEnum[] | ExamRecordAreaScalarFieldEnum
    having?: ExamRecordAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamRecordAreaCountAggregateInputType | true
    _min?: ExamRecordAreaMinAggregateInputType
    _max?: ExamRecordAreaMaxAggregateInputType
  }

  export type ExamRecordAreaGroupByOutputType = {
    id: string
    examRecordId: string
    areaId: string
    _count: ExamRecordAreaCountAggregateOutputType | null
    _min: ExamRecordAreaMinAggregateOutputType | null
    _max: ExamRecordAreaMaxAggregateOutputType | null
  }

  type GetExamRecordAreaGroupByPayload<T extends ExamRecordAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamRecordAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamRecordAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamRecordAreaGroupByOutputType[P]>
            : GetScalarType<T[P], ExamRecordAreaGroupByOutputType[P]>
        }
      >
    >


  export type ExamRecordAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    areaId?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordArea"]>

  export type ExamRecordAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    areaId?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordArea"]>

  export type ExamRecordAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    areaId?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordArea"]>

  export type ExamRecordAreaSelectScalar = {
    id?: boolean
    examRecordId?: boolean
    areaId?: boolean
  }

  export type ExamRecordAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examRecordId" | "areaId", ExtArgs["result"]["examRecordArea"]>
  export type ExamRecordAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }
  export type ExamRecordAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }
  export type ExamRecordAreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }

  export type $ExamRecordAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamRecordArea"
    objects: {
      examRecord: Prisma.$ExamRecordPayload<ExtArgs>
      area: Prisma.$AreaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examRecordId: string
      areaId: string
    }, ExtArgs["result"]["examRecordArea"]>
    composites: {}
  }

  type ExamRecordAreaGetPayload<S extends boolean | null | undefined | ExamRecordAreaDefaultArgs> = $Result.GetResult<Prisma.$ExamRecordAreaPayload, S>

  type ExamRecordAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamRecordAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamRecordAreaCountAggregateInputType | true
    }

  export interface ExamRecordAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamRecordArea'], meta: { name: 'ExamRecordArea' } }
    /**
     * Find zero or one ExamRecordArea that matches the filter.
     * @param {ExamRecordAreaFindUniqueArgs} args - Arguments to find a ExamRecordArea
     * @example
     * // Get one ExamRecordArea
     * const examRecordArea = await prisma.examRecordArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamRecordAreaFindUniqueArgs>(args: SelectSubset<T, ExamRecordAreaFindUniqueArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamRecordArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamRecordAreaFindUniqueOrThrowArgs} args - Arguments to find a ExamRecordArea
     * @example
     * // Get one ExamRecordArea
     * const examRecordArea = await prisma.examRecordArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamRecordAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamRecordAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecordArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAreaFindFirstArgs} args - Arguments to find a ExamRecordArea
     * @example
     * // Get one ExamRecordArea
     * const examRecordArea = await prisma.examRecordArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamRecordAreaFindFirstArgs>(args?: SelectSubset<T, ExamRecordAreaFindFirstArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecordArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAreaFindFirstOrThrowArgs} args - Arguments to find a ExamRecordArea
     * @example
     * // Get one ExamRecordArea
     * const examRecordArea = await prisma.examRecordArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamRecordAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamRecordAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamRecordAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamRecordAreas
     * const examRecordAreas = await prisma.examRecordArea.findMany()
     * 
     * // Get first 10 ExamRecordAreas
     * const examRecordAreas = await prisma.examRecordArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examRecordAreaWithIdOnly = await prisma.examRecordArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamRecordAreaFindManyArgs>(args?: SelectSubset<T, ExamRecordAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamRecordArea.
     * @param {ExamRecordAreaCreateArgs} args - Arguments to create a ExamRecordArea.
     * @example
     * // Create one ExamRecordArea
     * const ExamRecordArea = await prisma.examRecordArea.create({
     *   data: {
     *     // ... data to create a ExamRecordArea
     *   }
     * })
     * 
     */
    create<T extends ExamRecordAreaCreateArgs>(args: SelectSubset<T, ExamRecordAreaCreateArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamRecordAreas.
     * @param {ExamRecordAreaCreateManyArgs} args - Arguments to create many ExamRecordAreas.
     * @example
     * // Create many ExamRecordAreas
     * const examRecordArea = await prisma.examRecordArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamRecordAreaCreateManyArgs>(args?: SelectSubset<T, ExamRecordAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamRecordAreas and returns the data saved in the database.
     * @param {ExamRecordAreaCreateManyAndReturnArgs} args - Arguments to create many ExamRecordAreas.
     * @example
     * // Create many ExamRecordAreas
     * const examRecordArea = await prisma.examRecordArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamRecordAreas and only return the `id`
     * const examRecordAreaWithIdOnly = await prisma.examRecordArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamRecordAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamRecordAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamRecordArea.
     * @param {ExamRecordAreaDeleteArgs} args - Arguments to delete one ExamRecordArea.
     * @example
     * // Delete one ExamRecordArea
     * const ExamRecordArea = await prisma.examRecordArea.delete({
     *   where: {
     *     // ... filter to delete one ExamRecordArea
     *   }
     * })
     * 
     */
    delete<T extends ExamRecordAreaDeleteArgs>(args: SelectSubset<T, ExamRecordAreaDeleteArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamRecordArea.
     * @param {ExamRecordAreaUpdateArgs} args - Arguments to update one ExamRecordArea.
     * @example
     * // Update one ExamRecordArea
     * const examRecordArea = await prisma.examRecordArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamRecordAreaUpdateArgs>(args: SelectSubset<T, ExamRecordAreaUpdateArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamRecordAreas.
     * @param {ExamRecordAreaDeleteManyArgs} args - Arguments to filter ExamRecordAreas to delete.
     * @example
     * // Delete a few ExamRecordAreas
     * const { count } = await prisma.examRecordArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamRecordAreaDeleteManyArgs>(args?: SelectSubset<T, ExamRecordAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecordAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamRecordAreas
     * const examRecordArea = await prisma.examRecordArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamRecordAreaUpdateManyArgs>(args: SelectSubset<T, ExamRecordAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecordAreas and returns the data updated in the database.
     * @param {ExamRecordAreaUpdateManyAndReturnArgs} args - Arguments to update many ExamRecordAreas.
     * @example
     * // Update many ExamRecordAreas
     * const examRecordArea = await prisma.examRecordArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamRecordAreas and only return the `id`
     * const examRecordAreaWithIdOnly = await prisma.examRecordArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamRecordAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamRecordAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamRecordArea.
     * @param {ExamRecordAreaUpsertArgs} args - Arguments to update or create a ExamRecordArea.
     * @example
     * // Update or create a ExamRecordArea
     * const examRecordArea = await prisma.examRecordArea.upsert({
     *   create: {
     *     // ... data to create a ExamRecordArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamRecordArea we want to update
     *   }
     * })
     */
    upsert<T extends ExamRecordAreaUpsertArgs>(args: SelectSubset<T, ExamRecordAreaUpsertArgs<ExtArgs>>): Prisma__ExamRecordAreaClient<$Result.GetResult<Prisma.$ExamRecordAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamRecordAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAreaCountArgs} args - Arguments to filter ExamRecordAreas to count.
     * @example
     * // Count the number of ExamRecordAreas
     * const count = await prisma.examRecordArea.count({
     *   where: {
     *     // ... the filter for the ExamRecordAreas we want to count
     *   }
     * })
    **/
    count<T extends ExamRecordAreaCountArgs>(
      args?: Subset<T, ExamRecordAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamRecordAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamRecordArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamRecordAreaAggregateArgs>(args: Subset<T, ExamRecordAreaAggregateArgs>): Prisma.PrismaPromise<GetExamRecordAreaAggregateType<T>>

    /**
     * Group by ExamRecordArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamRecordAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamRecordAreaGroupByArgs['orderBy'] }
        : { orderBy?: ExamRecordAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamRecordAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamRecordAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamRecordArea model
   */
  readonly fields: ExamRecordAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamRecordArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamRecordAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examRecord<T extends ExamRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamRecordDefaultArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamRecordArea model
   */
  interface ExamRecordAreaFieldRefs {
    readonly id: FieldRef<"ExamRecordArea", 'String'>
    readonly examRecordId: FieldRef<"ExamRecordArea", 'String'>
    readonly areaId: FieldRef<"ExamRecordArea", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExamRecordArea findUnique
   */
  export type ExamRecordAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordArea to fetch.
     */
    where: ExamRecordAreaWhereUniqueInput
  }

  /**
   * ExamRecordArea findUniqueOrThrow
   */
  export type ExamRecordAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordArea to fetch.
     */
    where: ExamRecordAreaWhereUniqueInput
  }

  /**
   * ExamRecordArea findFirst
   */
  export type ExamRecordAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordArea to fetch.
     */
    where?: ExamRecordAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordAreas to fetch.
     */
    orderBy?: ExamRecordAreaOrderByWithRelationInput | ExamRecordAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecordAreas.
     */
    cursor?: ExamRecordAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecordAreas.
     */
    distinct?: ExamRecordAreaScalarFieldEnum | ExamRecordAreaScalarFieldEnum[]
  }

  /**
   * ExamRecordArea findFirstOrThrow
   */
  export type ExamRecordAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordArea to fetch.
     */
    where?: ExamRecordAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordAreas to fetch.
     */
    orderBy?: ExamRecordAreaOrderByWithRelationInput | ExamRecordAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecordAreas.
     */
    cursor?: ExamRecordAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecordAreas.
     */
    distinct?: ExamRecordAreaScalarFieldEnum | ExamRecordAreaScalarFieldEnum[]
  }

  /**
   * ExamRecordArea findMany
   */
  export type ExamRecordAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordAreas to fetch.
     */
    where?: ExamRecordAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordAreas to fetch.
     */
    orderBy?: ExamRecordAreaOrderByWithRelationInput | ExamRecordAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamRecordAreas.
     */
    cursor?: ExamRecordAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordAreas.
     */
    skip?: number
    distinct?: ExamRecordAreaScalarFieldEnum | ExamRecordAreaScalarFieldEnum[]
  }

  /**
   * ExamRecordArea create
   */
  export type ExamRecordAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamRecordArea.
     */
    data: XOR<ExamRecordAreaCreateInput, ExamRecordAreaUncheckedCreateInput>
  }

  /**
   * ExamRecordArea createMany
   */
  export type ExamRecordAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamRecordAreas.
     */
    data: ExamRecordAreaCreateManyInput | ExamRecordAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamRecordArea createManyAndReturn
   */
  export type ExamRecordAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * The data used to create many ExamRecordAreas.
     */
    data: ExamRecordAreaCreateManyInput | ExamRecordAreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecordArea update
   */
  export type ExamRecordAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamRecordArea.
     */
    data: XOR<ExamRecordAreaUpdateInput, ExamRecordAreaUncheckedUpdateInput>
    /**
     * Choose, which ExamRecordArea to update.
     */
    where: ExamRecordAreaWhereUniqueInput
  }

  /**
   * ExamRecordArea updateMany
   */
  export type ExamRecordAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamRecordAreas.
     */
    data: XOR<ExamRecordAreaUpdateManyMutationInput, ExamRecordAreaUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecordAreas to update
     */
    where?: ExamRecordAreaWhereInput
    /**
     * Limit how many ExamRecordAreas to update.
     */
    limit?: number
  }

  /**
   * ExamRecordArea updateManyAndReturn
   */
  export type ExamRecordAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * The data used to update ExamRecordAreas.
     */
    data: XOR<ExamRecordAreaUpdateManyMutationInput, ExamRecordAreaUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecordAreas to update
     */
    where?: ExamRecordAreaWhereInput
    /**
     * Limit how many ExamRecordAreas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecordArea upsert
   */
  export type ExamRecordAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamRecordArea to update in case it exists.
     */
    where: ExamRecordAreaWhereUniqueInput
    /**
     * In case the ExamRecordArea found by the `where` argument doesn't exist, create a new ExamRecordArea with this data.
     */
    create: XOR<ExamRecordAreaCreateInput, ExamRecordAreaUncheckedCreateInput>
    /**
     * In case the ExamRecordArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamRecordAreaUpdateInput, ExamRecordAreaUncheckedUpdateInput>
  }

  /**
   * ExamRecordArea delete
   */
  export type ExamRecordAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
    /**
     * Filter which ExamRecordArea to delete.
     */
    where: ExamRecordAreaWhereUniqueInput
  }

  /**
   * ExamRecordArea deleteMany
   */
  export type ExamRecordAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecordAreas to delete
     */
    where?: ExamRecordAreaWhereInput
    /**
     * Limit how many ExamRecordAreas to delete.
     */
    limit?: number
  }

  /**
   * ExamRecordArea without action
   */
  export type ExamRecordAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordArea
     */
    select?: ExamRecordAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordArea
     */
    omit?: ExamRecordAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordAreaInclude<ExtArgs> | null
  }


  /**
   * Model ExamRecordPart
   */

  export type AggregateExamRecordPart = {
    _count: ExamRecordPartCountAggregateOutputType | null
    _avg: ExamRecordPartAvgAggregateOutputType | null
    _sum: ExamRecordPartSumAggregateOutputType | null
    _min: ExamRecordPartMinAggregateOutputType | null
    _max: ExamRecordPartMaxAggregateOutputType | null
  }

  export type ExamRecordPartAvgAggregateOutputType = {
    externalId: number | null
  }

  export type ExamRecordPartSumAggregateOutputType = {
    externalId: number | null
  }

  export type ExamRecordPartMinAggregateOutputType = {
    id: string | null
    examRecordId: string | null
    externalId: number | null
    description: string | null
  }

  export type ExamRecordPartMaxAggregateOutputType = {
    id: string | null
    examRecordId: string | null
    externalId: number | null
    description: string | null
  }

  export type ExamRecordPartCountAggregateOutputType = {
    id: number
    examRecordId: number
    externalId: number
    description: number
    _all: number
  }


  export type ExamRecordPartAvgAggregateInputType = {
    externalId?: true
  }

  export type ExamRecordPartSumAggregateInputType = {
    externalId?: true
  }

  export type ExamRecordPartMinAggregateInputType = {
    id?: true
    examRecordId?: true
    externalId?: true
    description?: true
  }

  export type ExamRecordPartMaxAggregateInputType = {
    id?: true
    examRecordId?: true
    externalId?: true
    description?: true
  }

  export type ExamRecordPartCountAggregateInputType = {
    id?: true
    examRecordId?: true
    externalId?: true
    description?: true
    _all?: true
  }

  export type ExamRecordPartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecordPart to aggregate.
     */
    where?: ExamRecordPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordParts to fetch.
     */
    orderBy?: ExamRecordPartOrderByWithRelationInput | ExamRecordPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamRecordPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamRecordParts
    **/
    _count?: true | ExamRecordPartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamRecordPartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamRecordPartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamRecordPartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamRecordPartMaxAggregateInputType
  }

  export type GetExamRecordPartAggregateType<T extends ExamRecordPartAggregateArgs> = {
        [P in keyof T & keyof AggregateExamRecordPart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamRecordPart[P]>
      : GetScalarType<T[P], AggregateExamRecordPart[P]>
  }




  export type ExamRecordPartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamRecordPartWhereInput
    orderBy?: ExamRecordPartOrderByWithAggregationInput | ExamRecordPartOrderByWithAggregationInput[]
    by: ExamRecordPartScalarFieldEnum[] | ExamRecordPartScalarFieldEnum
    having?: ExamRecordPartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamRecordPartCountAggregateInputType | true
    _avg?: ExamRecordPartAvgAggregateInputType
    _sum?: ExamRecordPartSumAggregateInputType
    _min?: ExamRecordPartMinAggregateInputType
    _max?: ExamRecordPartMaxAggregateInputType
  }

  export type ExamRecordPartGroupByOutputType = {
    id: string
    examRecordId: string
    externalId: number | null
    description: string
    _count: ExamRecordPartCountAggregateOutputType | null
    _avg: ExamRecordPartAvgAggregateOutputType | null
    _sum: ExamRecordPartSumAggregateOutputType | null
    _min: ExamRecordPartMinAggregateOutputType | null
    _max: ExamRecordPartMaxAggregateOutputType | null
  }

  type GetExamRecordPartGroupByPayload<T extends ExamRecordPartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamRecordPartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamRecordPartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamRecordPartGroupByOutputType[P]>
            : GetScalarType<T[P], ExamRecordPartGroupByOutputType[P]>
        }
      >
    >


  export type ExamRecordPartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    externalId?: boolean
    description?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordPart"]>

  export type ExamRecordPartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    externalId?: boolean
    description?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordPart"]>

  export type ExamRecordPartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examRecordId?: boolean
    externalId?: boolean
    description?: boolean
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examRecordPart"]>

  export type ExamRecordPartSelectScalar = {
    id?: boolean
    examRecordId?: boolean
    externalId?: boolean
    description?: boolean
  }

  export type ExamRecordPartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examRecordId" | "externalId" | "description", ExtArgs["result"]["examRecordPart"]>
  export type ExamRecordPartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
  }
  export type ExamRecordPartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
  }
  export type ExamRecordPartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examRecord?: boolean | ExamRecordDefaultArgs<ExtArgs>
  }

  export type $ExamRecordPartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamRecordPart"
    objects: {
      examRecord: Prisma.$ExamRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examRecordId: string
      externalId: number | null
      description: string
    }, ExtArgs["result"]["examRecordPart"]>
    composites: {}
  }

  type ExamRecordPartGetPayload<S extends boolean | null | undefined | ExamRecordPartDefaultArgs> = $Result.GetResult<Prisma.$ExamRecordPartPayload, S>

  type ExamRecordPartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamRecordPartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamRecordPartCountAggregateInputType | true
    }

  export interface ExamRecordPartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamRecordPart'], meta: { name: 'ExamRecordPart' } }
    /**
     * Find zero or one ExamRecordPart that matches the filter.
     * @param {ExamRecordPartFindUniqueArgs} args - Arguments to find a ExamRecordPart
     * @example
     * // Get one ExamRecordPart
     * const examRecordPart = await prisma.examRecordPart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamRecordPartFindUniqueArgs>(args: SelectSubset<T, ExamRecordPartFindUniqueArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamRecordPart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamRecordPartFindUniqueOrThrowArgs} args - Arguments to find a ExamRecordPart
     * @example
     * // Get one ExamRecordPart
     * const examRecordPart = await prisma.examRecordPart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamRecordPartFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamRecordPartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecordPart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordPartFindFirstArgs} args - Arguments to find a ExamRecordPart
     * @example
     * // Get one ExamRecordPart
     * const examRecordPart = await prisma.examRecordPart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamRecordPartFindFirstArgs>(args?: SelectSubset<T, ExamRecordPartFindFirstArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamRecordPart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordPartFindFirstOrThrowArgs} args - Arguments to find a ExamRecordPart
     * @example
     * // Get one ExamRecordPart
     * const examRecordPart = await prisma.examRecordPart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamRecordPartFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamRecordPartFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamRecordParts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordPartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamRecordParts
     * const examRecordParts = await prisma.examRecordPart.findMany()
     * 
     * // Get first 10 ExamRecordParts
     * const examRecordParts = await prisma.examRecordPart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examRecordPartWithIdOnly = await prisma.examRecordPart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamRecordPartFindManyArgs>(args?: SelectSubset<T, ExamRecordPartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamRecordPart.
     * @param {ExamRecordPartCreateArgs} args - Arguments to create a ExamRecordPart.
     * @example
     * // Create one ExamRecordPart
     * const ExamRecordPart = await prisma.examRecordPart.create({
     *   data: {
     *     // ... data to create a ExamRecordPart
     *   }
     * })
     * 
     */
    create<T extends ExamRecordPartCreateArgs>(args: SelectSubset<T, ExamRecordPartCreateArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamRecordParts.
     * @param {ExamRecordPartCreateManyArgs} args - Arguments to create many ExamRecordParts.
     * @example
     * // Create many ExamRecordParts
     * const examRecordPart = await prisma.examRecordPart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamRecordPartCreateManyArgs>(args?: SelectSubset<T, ExamRecordPartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamRecordParts and returns the data saved in the database.
     * @param {ExamRecordPartCreateManyAndReturnArgs} args - Arguments to create many ExamRecordParts.
     * @example
     * // Create many ExamRecordParts
     * const examRecordPart = await prisma.examRecordPart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamRecordParts and only return the `id`
     * const examRecordPartWithIdOnly = await prisma.examRecordPart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamRecordPartCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamRecordPartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamRecordPart.
     * @param {ExamRecordPartDeleteArgs} args - Arguments to delete one ExamRecordPart.
     * @example
     * // Delete one ExamRecordPart
     * const ExamRecordPart = await prisma.examRecordPart.delete({
     *   where: {
     *     // ... filter to delete one ExamRecordPart
     *   }
     * })
     * 
     */
    delete<T extends ExamRecordPartDeleteArgs>(args: SelectSubset<T, ExamRecordPartDeleteArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamRecordPart.
     * @param {ExamRecordPartUpdateArgs} args - Arguments to update one ExamRecordPart.
     * @example
     * // Update one ExamRecordPart
     * const examRecordPart = await prisma.examRecordPart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamRecordPartUpdateArgs>(args: SelectSubset<T, ExamRecordPartUpdateArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamRecordParts.
     * @param {ExamRecordPartDeleteManyArgs} args - Arguments to filter ExamRecordParts to delete.
     * @example
     * // Delete a few ExamRecordParts
     * const { count } = await prisma.examRecordPart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamRecordPartDeleteManyArgs>(args?: SelectSubset<T, ExamRecordPartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecordParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordPartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamRecordParts
     * const examRecordPart = await prisma.examRecordPart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamRecordPartUpdateManyArgs>(args: SelectSubset<T, ExamRecordPartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamRecordParts and returns the data updated in the database.
     * @param {ExamRecordPartUpdateManyAndReturnArgs} args - Arguments to update many ExamRecordParts.
     * @example
     * // Update many ExamRecordParts
     * const examRecordPart = await prisma.examRecordPart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamRecordParts and only return the `id`
     * const examRecordPartWithIdOnly = await prisma.examRecordPart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamRecordPartUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamRecordPartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamRecordPart.
     * @param {ExamRecordPartUpsertArgs} args - Arguments to update or create a ExamRecordPart.
     * @example
     * // Update or create a ExamRecordPart
     * const examRecordPart = await prisma.examRecordPart.upsert({
     *   create: {
     *     // ... data to create a ExamRecordPart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamRecordPart we want to update
     *   }
     * })
     */
    upsert<T extends ExamRecordPartUpsertArgs>(args: SelectSubset<T, ExamRecordPartUpsertArgs<ExtArgs>>): Prisma__ExamRecordPartClient<$Result.GetResult<Prisma.$ExamRecordPartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamRecordParts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordPartCountArgs} args - Arguments to filter ExamRecordParts to count.
     * @example
     * // Count the number of ExamRecordParts
     * const count = await prisma.examRecordPart.count({
     *   where: {
     *     // ... the filter for the ExamRecordParts we want to count
     *   }
     * })
    **/
    count<T extends ExamRecordPartCountArgs>(
      args?: Subset<T, ExamRecordPartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamRecordPartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamRecordPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordPartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamRecordPartAggregateArgs>(args: Subset<T, ExamRecordPartAggregateArgs>): Prisma.PrismaPromise<GetExamRecordPartAggregateType<T>>

    /**
     * Group by ExamRecordPart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamRecordPartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamRecordPartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamRecordPartGroupByArgs['orderBy'] }
        : { orderBy?: ExamRecordPartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamRecordPartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamRecordPartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamRecordPart model
   */
  readonly fields: ExamRecordPartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamRecordPart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamRecordPartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examRecord<T extends ExamRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamRecordDefaultArgs<ExtArgs>>): Prisma__ExamRecordClient<$Result.GetResult<Prisma.$ExamRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamRecordPart model
   */
  interface ExamRecordPartFieldRefs {
    readonly id: FieldRef<"ExamRecordPart", 'String'>
    readonly examRecordId: FieldRef<"ExamRecordPart", 'String'>
    readonly externalId: FieldRef<"ExamRecordPart", 'Int'>
    readonly description: FieldRef<"ExamRecordPart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExamRecordPart findUnique
   */
  export type ExamRecordPartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordPart to fetch.
     */
    where: ExamRecordPartWhereUniqueInput
  }

  /**
   * ExamRecordPart findUniqueOrThrow
   */
  export type ExamRecordPartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordPart to fetch.
     */
    where: ExamRecordPartWhereUniqueInput
  }

  /**
   * ExamRecordPart findFirst
   */
  export type ExamRecordPartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordPart to fetch.
     */
    where?: ExamRecordPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordParts to fetch.
     */
    orderBy?: ExamRecordPartOrderByWithRelationInput | ExamRecordPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecordParts.
     */
    cursor?: ExamRecordPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecordParts.
     */
    distinct?: ExamRecordPartScalarFieldEnum | ExamRecordPartScalarFieldEnum[]
  }

  /**
   * ExamRecordPart findFirstOrThrow
   */
  export type ExamRecordPartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordPart to fetch.
     */
    where?: ExamRecordPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordParts to fetch.
     */
    orderBy?: ExamRecordPartOrderByWithRelationInput | ExamRecordPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamRecordParts.
     */
    cursor?: ExamRecordPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordParts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamRecordParts.
     */
    distinct?: ExamRecordPartScalarFieldEnum | ExamRecordPartScalarFieldEnum[]
  }

  /**
   * ExamRecordPart findMany
   */
  export type ExamRecordPartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * Filter, which ExamRecordParts to fetch.
     */
    where?: ExamRecordPartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamRecordParts to fetch.
     */
    orderBy?: ExamRecordPartOrderByWithRelationInput | ExamRecordPartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamRecordParts.
     */
    cursor?: ExamRecordPartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamRecordParts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamRecordParts.
     */
    skip?: number
    distinct?: ExamRecordPartScalarFieldEnum | ExamRecordPartScalarFieldEnum[]
  }

  /**
   * ExamRecordPart create
   */
  export type ExamRecordPartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamRecordPart.
     */
    data: XOR<ExamRecordPartCreateInput, ExamRecordPartUncheckedCreateInput>
  }

  /**
   * ExamRecordPart createMany
   */
  export type ExamRecordPartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamRecordParts.
     */
    data: ExamRecordPartCreateManyInput | ExamRecordPartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamRecordPart createManyAndReturn
   */
  export type ExamRecordPartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * The data used to create many ExamRecordParts.
     */
    data: ExamRecordPartCreateManyInput | ExamRecordPartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecordPart update
   */
  export type ExamRecordPartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamRecordPart.
     */
    data: XOR<ExamRecordPartUpdateInput, ExamRecordPartUncheckedUpdateInput>
    /**
     * Choose, which ExamRecordPart to update.
     */
    where: ExamRecordPartWhereUniqueInput
  }

  /**
   * ExamRecordPart updateMany
   */
  export type ExamRecordPartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamRecordParts.
     */
    data: XOR<ExamRecordPartUpdateManyMutationInput, ExamRecordPartUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecordParts to update
     */
    where?: ExamRecordPartWhereInput
    /**
     * Limit how many ExamRecordParts to update.
     */
    limit?: number
  }

  /**
   * ExamRecordPart updateManyAndReturn
   */
  export type ExamRecordPartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * The data used to update ExamRecordParts.
     */
    data: XOR<ExamRecordPartUpdateManyMutationInput, ExamRecordPartUncheckedUpdateManyInput>
    /**
     * Filter which ExamRecordParts to update
     */
    where?: ExamRecordPartWhereInput
    /**
     * Limit how many ExamRecordParts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamRecordPart upsert
   */
  export type ExamRecordPartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamRecordPart to update in case it exists.
     */
    where: ExamRecordPartWhereUniqueInput
    /**
     * In case the ExamRecordPart found by the `where` argument doesn't exist, create a new ExamRecordPart with this data.
     */
    create: XOR<ExamRecordPartCreateInput, ExamRecordPartUncheckedCreateInput>
    /**
     * In case the ExamRecordPart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamRecordPartUpdateInput, ExamRecordPartUncheckedUpdateInput>
  }

  /**
   * ExamRecordPart delete
   */
  export type ExamRecordPartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
    /**
     * Filter which ExamRecordPart to delete.
     */
    where: ExamRecordPartWhereUniqueInput
  }

  /**
   * ExamRecordPart deleteMany
   */
  export type ExamRecordPartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamRecordParts to delete
     */
    where?: ExamRecordPartWhereInput
    /**
     * Limit how many ExamRecordParts to delete.
     */
    limit?: number
  }

  /**
   * ExamRecordPart without action
   */
  export type ExamRecordPartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamRecordPart
     */
    select?: ExamRecordPartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamRecordPart
     */
    omit?: ExamRecordPartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamRecordPartInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    year: 'year',
    organization: 'organization',
    institution: 'institution',
    level: 'level',
    sourceUrl: 'sourceUrl',
    examPdfUrl: 'examPdfUrl',
    answerKeyUrl: 'answerKeyUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    statement: 'statement',
    organization: 'organization',
    subject: 'subject',
    examId: 'examId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AlternativeScalarFieldEnum: {
    id: 'id',
    text: 'text',
    isCorrect: 'isCorrect',
    questionId: 'questionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlternativeScalarFieldEnum = (typeof AlternativeScalarFieldEnum)[keyof typeof AlternativeScalarFieldEnum]


  export const SimulationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    title: 'title',
    createdAt: 'createdAt',
    finishedAt: 'finishedAt'
  };

  export type SimulationScalarFieldEnum = (typeof SimulationScalarFieldEnum)[keyof typeof SimulationScalarFieldEnum]


  export const SimulationAnswerScalarFieldEnum: {
    id: 'id',
    simulationId: 'simulationId',
    questionId: 'questionId',
    alternativeId: 'alternativeId',
    createdAt: 'createdAt'
  };

  export type SimulationAnswerScalarFieldEnum = (typeof SimulationAnswerScalarFieldEnum)[keyof typeof SimulationAnswerScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    name: 'name',
    acronym: 'acronym',
    sphere: 'sphere',
    state: 'state',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    name: 'name',
    description: 'description',
    acronym: 'acronym',
    isOab: 'isOab',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    name: 'name',
    description: 'description',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    slug: 'slug',
    enrollmentStart: 'enrollmentStart',
    enrollmentEnd: 'enrollmentEnd',
    plannedApplication: 'plannedApplication',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const CareerScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CareerScalarFieldEnum = (typeof CareerScalarFieldEnum)[keyof typeof CareerScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const ExamRecordScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    slug: 'slug',
    name: 'name',
    type: 'type',
    year: 'year',
    level: 'level',
    questionCount: 'questionCount',
    durationMinutes: 'durationMinutes',
    reviewed: 'reviewed',
    hasPendencies: 'hasPendencies',
    available: 'available',
    observations: 'observations',
    otherData: 'otherData',
    timestamp: 'timestamp',
    publishedAt: 'publishedAt',
    applicationDate: 'applicationDate',
    examFileKey: 'examFileKey',
    answerKeyFileKey: 'answerKeyFileKey',
    organizationId: 'organizationId',
    boardId: 'boardId',
    positionId: 'positionId',
    noticeId: 'noticeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamRecordScalarFieldEnum = (typeof ExamRecordScalarFieldEnum)[keyof typeof ExamRecordScalarFieldEnum]


  export const ExamRecordCareerScalarFieldEnum: {
    id: 'id',
    examRecordId: 'examRecordId',
    careerId: 'careerId'
  };

  export type ExamRecordCareerScalarFieldEnum = (typeof ExamRecordCareerScalarFieldEnum)[keyof typeof ExamRecordCareerScalarFieldEnum]


  export const ExamRecordAreaScalarFieldEnum: {
    id: 'id',
    examRecordId: 'examRecordId',
    areaId: 'areaId'
  };

  export type ExamRecordAreaScalarFieldEnum = (typeof ExamRecordAreaScalarFieldEnum)[keyof typeof ExamRecordAreaScalarFieldEnum]


  export const ExamRecordPartScalarFieldEnum: {
    id: 'id',
    examRecordId: 'examRecordId',
    externalId: 'externalId',
    description: 'description'
  };

  export type ExamRecordPartScalarFieldEnum = (typeof ExamRecordPartScalarFieldEnum)[keyof typeof ExamRecordPartScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    year?: IntFilter<"Exam"> | number
    organization?: StringFilter<"Exam"> | string
    institution?: StringFilter<"Exam"> | string
    level?: StringFilter<"Exam"> | string
    sourceUrl?: StringNullableFilter<"Exam"> | string | null
    examPdfUrl?: StringNullableFilter<"Exam"> | string | null
    answerKeyUrl?: StringNullableFilter<"Exam"> | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    questions?: QuestionListRelationFilter
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    organization?: SortOrder
    institution?: SortOrder
    level?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    examPdfUrl?: SortOrderInput | SortOrder
    answerKeyUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: QuestionOrderByRelationAggregateInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    year?: IntFilter<"Exam"> | number
    organization?: StringFilter<"Exam"> | string
    institution?: StringFilter<"Exam"> | string
    level?: StringFilter<"Exam"> | string
    sourceUrl?: StringNullableFilter<"Exam"> | string | null
    examPdfUrl?: StringNullableFilter<"Exam"> | string | null
    answerKeyUrl?: StringNullableFilter<"Exam"> | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    questions?: QuestionListRelationFilter
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    organization?: SortOrder
    institution?: SortOrder
    level?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    examPdfUrl?: SortOrderInput | SortOrder
    answerKeyUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    year?: IntWithAggregatesFilter<"Exam"> | number
    organization?: StringWithAggregatesFilter<"Exam"> | string
    institution?: StringWithAggregatesFilter<"Exam"> | string
    level?: StringWithAggregatesFilter<"Exam"> | string
    sourceUrl?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    examPdfUrl?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    answerKeyUrl?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    statement?: StringFilter<"Question"> | string
    organization?: StringFilter<"Question"> | string
    subject?: StringFilter<"Question"> | string
    examId?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    alternatives?: AlternativeListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    statement?: SortOrder
    organization?: SortOrder
    subject?: SortOrder
    examId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exam?: ExamOrderByWithRelationInput
    alternatives?: AlternativeOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    statement?: StringFilter<"Question"> | string
    organization?: StringFilter<"Question"> | string
    subject?: StringFilter<"Question"> | string
    examId?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    exam?: XOR<ExamNullableScalarRelationFilter, ExamWhereInput> | null
    alternatives?: AlternativeListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    statement?: SortOrder
    organization?: SortOrder
    subject?: SortOrder
    examId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    statement?: StringWithAggregatesFilter<"Question"> | string
    organization?: StringWithAggregatesFilter<"Question"> | string
    subject?: StringWithAggregatesFilter<"Question"> | string
    examId?: StringNullableWithAggregatesFilter<"Question"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
  }

  export type AlternativeWhereInput = {
    AND?: AlternativeWhereInput | AlternativeWhereInput[]
    OR?: AlternativeWhereInput[]
    NOT?: AlternativeWhereInput | AlternativeWhereInput[]
    id?: StringFilter<"Alternative"> | string
    text?: StringFilter<"Alternative"> | string
    isCorrect?: BoolFilter<"Alternative"> | boolean
    questionId?: StringFilter<"Alternative"> | string
    createdAt?: DateTimeFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeFilter<"Alternative"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }

  export type AlternativeOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type AlternativeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlternativeWhereInput | AlternativeWhereInput[]
    OR?: AlternativeWhereInput[]
    NOT?: AlternativeWhereInput | AlternativeWhereInput[]
    text?: StringFilter<"Alternative"> | string
    isCorrect?: BoolFilter<"Alternative"> | boolean
    questionId?: StringFilter<"Alternative"> | string
    createdAt?: DateTimeFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeFilter<"Alternative"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }, "id">

  export type AlternativeOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlternativeCountOrderByAggregateInput
    _max?: AlternativeMaxOrderByAggregateInput
    _min?: AlternativeMinOrderByAggregateInput
  }

  export type AlternativeScalarWhereWithAggregatesInput = {
    AND?: AlternativeScalarWhereWithAggregatesInput | AlternativeScalarWhereWithAggregatesInput[]
    OR?: AlternativeScalarWhereWithAggregatesInput[]
    NOT?: AlternativeScalarWhereWithAggregatesInput | AlternativeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alternative"> | string
    text?: StringWithAggregatesFilter<"Alternative"> | string
    isCorrect?: BoolWithAggregatesFilter<"Alternative"> | boolean
    questionId?: StringWithAggregatesFilter<"Alternative"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alternative"> | Date | string
  }

  export type SimulationWhereInput = {
    AND?: SimulationWhereInput | SimulationWhereInput[]
    OR?: SimulationWhereInput[]
    NOT?: SimulationWhereInput | SimulationWhereInput[]
    id?: StringFilter<"Simulation"> | string
    studentId?: StringFilter<"Simulation"> | string
    title?: StringFilter<"Simulation"> | string
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    finishedAt?: DateTimeNullableFilter<"Simulation"> | Date | string | null
    answers?: SimulationAnswerListRelationFilter
  }

  export type SimulationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    answers?: SimulationAnswerOrderByRelationAggregateInput
  }

  export type SimulationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimulationWhereInput | SimulationWhereInput[]
    OR?: SimulationWhereInput[]
    NOT?: SimulationWhereInput | SimulationWhereInput[]
    studentId?: StringFilter<"Simulation"> | string
    title?: StringFilter<"Simulation"> | string
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    finishedAt?: DateTimeNullableFilter<"Simulation"> | Date | string | null
    answers?: SimulationAnswerListRelationFilter
  }, "id">

  export type SimulationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    _count?: SimulationCountOrderByAggregateInput
    _max?: SimulationMaxOrderByAggregateInput
    _min?: SimulationMinOrderByAggregateInput
  }

  export type SimulationScalarWhereWithAggregatesInput = {
    AND?: SimulationScalarWhereWithAggregatesInput | SimulationScalarWhereWithAggregatesInput[]
    OR?: SimulationScalarWhereWithAggregatesInput[]
    NOT?: SimulationScalarWhereWithAggregatesInput | SimulationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Simulation"> | string
    studentId?: StringWithAggregatesFilter<"Simulation"> | string
    title?: StringWithAggregatesFilter<"Simulation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Simulation"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"Simulation"> | Date | string | null
  }

  export type SimulationAnswerWhereInput = {
    AND?: SimulationAnswerWhereInput | SimulationAnswerWhereInput[]
    OR?: SimulationAnswerWhereInput[]
    NOT?: SimulationAnswerWhereInput | SimulationAnswerWhereInput[]
    id?: StringFilter<"SimulationAnswer"> | string
    simulationId?: StringFilter<"SimulationAnswer"> | string
    questionId?: StringFilter<"SimulationAnswer"> | string
    alternativeId?: StringFilter<"SimulationAnswer"> | string
    createdAt?: DateTimeFilter<"SimulationAnswer"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }

  export type SimulationAnswerOrderByWithRelationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
    createdAt?: SortOrder
    simulation?: SimulationOrderByWithRelationInput
  }

  export type SimulationAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    simulationId_questionId?: SimulationAnswerSimulationIdQuestionIdCompoundUniqueInput
    AND?: SimulationAnswerWhereInput | SimulationAnswerWhereInput[]
    OR?: SimulationAnswerWhereInput[]
    NOT?: SimulationAnswerWhereInput | SimulationAnswerWhereInput[]
    simulationId?: StringFilter<"SimulationAnswer"> | string
    questionId?: StringFilter<"SimulationAnswer"> | string
    alternativeId?: StringFilter<"SimulationAnswer"> | string
    createdAt?: DateTimeFilter<"SimulationAnswer"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
  }, "id" | "simulationId_questionId">

  export type SimulationAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
    createdAt?: SortOrder
    _count?: SimulationAnswerCountOrderByAggregateInput
    _max?: SimulationAnswerMaxOrderByAggregateInput
    _min?: SimulationAnswerMinOrderByAggregateInput
  }

  export type SimulationAnswerScalarWhereWithAggregatesInput = {
    AND?: SimulationAnswerScalarWhereWithAggregatesInput | SimulationAnswerScalarWhereWithAggregatesInput[]
    OR?: SimulationAnswerScalarWhereWithAggregatesInput[]
    NOT?: SimulationAnswerScalarWhereWithAggregatesInput | SimulationAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimulationAnswer"> | string
    simulationId?: StringWithAggregatesFilter<"SimulationAnswer"> | string
    questionId?: StringWithAggregatesFilter<"SimulationAnswer"> | string
    alternativeId?: StringWithAggregatesFilter<"SimulationAnswer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SimulationAnswer"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    externalId?: IntFilter<"Organization"> | number
    name?: StringFilter<"Organization"> | string
    acronym?: StringNullableFilter<"Organization"> | string | null
    sphere?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    slug?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    acronym?: SortOrderInput | SortOrder
    sphere?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examRecords?: ExamRecordOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: number
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    acronym?: StringNullableFilter<"Organization"> | string | null
    sphere?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    slug?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }, "id" | "externalId">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    acronym?: SortOrderInput | SortOrder
    sphere?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    externalId?: IntWithAggregatesFilter<"Organization"> | number
    name?: StringWithAggregatesFilter<"Organization"> | string
    acronym?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    sphere?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    state?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    slug?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type BoardWhereInput = {
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    id?: StringFilter<"Board"> | string
    externalId?: IntFilter<"Board"> | number
    name?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    acronym?: StringNullableFilter<"Board"> | string | null
    isOab?: BoolFilter<"Board"> | boolean
    slug?: StringNullableFilter<"Board"> | string | null
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    acronym?: SortOrderInput | SortOrder
    isOab?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examRecords?: ExamRecordOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: number
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    name?: StringFilter<"Board"> | string
    description?: StringNullableFilter<"Board"> | string | null
    acronym?: StringNullableFilter<"Board"> | string | null
    isOab?: BoolFilter<"Board"> | boolean
    slug?: StringNullableFilter<"Board"> | string | null
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }, "id" | "externalId">

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    acronym?: SortOrderInput | SortOrder
    isOab?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _avg?: BoardAvgOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
    _sum?: BoardSumOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    OR?: BoardScalarWhereWithAggregatesInput[]
    NOT?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Board"> | string
    externalId?: IntWithAggregatesFilter<"Board"> | number
    name?: StringWithAggregatesFilter<"Board"> | string
    description?: StringNullableWithAggregatesFilter<"Board"> | string | null
    acronym?: StringNullableWithAggregatesFilter<"Board"> | string | null
    isOab?: BoolWithAggregatesFilter<"Board"> | boolean
    slug?: StringNullableWithAggregatesFilter<"Board"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: StringFilter<"Position"> | string
    externalId?: IntFilter<"Position"> | number
    name?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    slug?: StringNullableFilter<"Position"> | string | null
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examRecords?: ExamRecordOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: number
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    name?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    slug?: StringNullableFilter<"Position"> | string | null
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }, "id" | "externalId">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Position"> | string
    externalId?: IntWithAggregatesFilter<"Position"> | number
    name?: StringWithAggregatesFilter<"Position"> | string
    description?: StringNullableWithAggregatesFilter<"Position"> | string | null
    slug?: StringNullableWithAggregatesFilter<"Position"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
  }

  export type NoticeWhereInput = {
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    id?: StringFilter<"Notice"> | string
    externalId?: IntFilter<"Notice"> | number
    slug?: StringNullableFilter<"Notice"> | string | null
    enrollmentStart?: DateTimeNullableFilter<"Notice"> | Date | string | null
    enrollmentEnd?: DateTimeNullableFilter<"Notice"> | Date | string | null
    plannedApplication?: DateTimeNullableFilter<"Notice"> | Date | string | null
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    updatedAt?: DateTimeFilter<"Notice"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrderInput | SortOrder
    enrollmentStart?: SortOrderInput | SortOrder
    enrollmentEnd?: SortOrderInput | SortOrder
    plannedApplication?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examRecords?: ExamRecordOrderByRelationAggregateInput
  }

  export type NoticeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: number
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    slug?: StringNullableFilter<"Notice"> | string | null
    enrollmentStart?: DateTimeNullableFilter<"Notice"> | Date | string | null
    enrollmentEnd?: DateTimeNullableFilter<"Notice"> | Date | string | null
    plannedApplication?: DateTimeNullableFilter<"Notice"> | Date | string | null
    createdAt?: DateTimeFilter<"Notice"> | Date | string
    updatedAt?: DateTimeFilter<"Notice"> | Date | string
    examRecords?: ExamRecordListRelationFilter
  }, "id" | "externalId">

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrderInput | SortOrder
    enrollmentStart?: SortOrderInput | SortOrder
    enrollmentEnd?: SortOrderInput | SortOrder
    plannedApplication?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    OR?: NoticeScalarWhereWithAggregatesInput[]
    NOT?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notice"> | string
    externalId?: IntWithAggregatesFilter<"Notice"> | number
    slug?: StringNullableWithAggregatesFilter<"Notice"> | string | null
    enrollmentStart?: DateTimeNullableWithAggregatesFilter<"Notice"> | Date | string | null
    enrollmentEnd?: DateTimeNullableWithAggregatesFilter<"Notice"> | Date | string | null
    plannedApplication?: DateTimeNullableWithAggregatesFilter<"Notice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
  }

  export type CareerWhereInput = {
    AND?: CareerWhereInput | CareerWhereInput[]
    OR?: CareerWhereInput[]
    NOT?: CareerWhereInput | CareerWhereInput[]
    id?: StringFilter<"Career"> | string
    externalId?: IntFilter<"Career"> | number
    name?: StringFilter<"Career"> | string
    description?: StringNullableFilter<"Career"> | string | null
    createdAt?: DateTimeFilter<"Career"> | Date | string
    updatedAt?: DateTimeFilter<"Career"> | Date | string
    exams?: ExamRecordCareerListRelationFilter
  }

  export type CareerOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exams?: ExamRecordCareerOrderByRelationAggregateInput
  }

  export type CareerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: number
    AND?: CareerWhereInput | CareerWhereInput[]
    OR?: CareerWhereInput[]
    NOT?: CareerWhereInput | CareerWhereInput[]
    name?: StringFilter<"Career"> | string
    description?: StringNullableFilter<"Career"> | string | null
    createdAt?: DateTimeFilter<"Career"> | Date | string
    updatedAt?: DateTimeFilter<"Career"> | Date | string
    exams?: ExamRecordCareerListRelationFilter
  }, "id" | "externalId">

  export type CareerOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CareerCountOrderByAggregateInput
    _avg?: CareerAvgOrderByAggregateInput
    _max?: CareerMaxOrderByAggregateInput
    _min?: CareerMinOrderByAggregateInput
    _sum?: CareerSumOrderByAggregateInput
  }

  export type CareerScalarWhereWithAggregatesInput = {
    AND?: CareerScalarWhereWithAggregatesInput | CareerScalarWhereWithAggregatesInput[]
    OR?: CareerScalarWhereWithAggregatesInput[]
    NOT?: CareerScalarWhereWithAggregatesInput | CareerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Career"> | string
    externalId?: IntWithAggregatesFilter<"Career"> | number
    name?: StringWithAggregatesFilter<"Career"> | string
    description?: StringNullableWithAggregatesFilter<"Career"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Career"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Career"> | Date | string
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: StringFilter<"Area"> | string
    externalId?: IntFilter<"Area"> | number
    name?: StringFilter<"Area"> | string
    slug?: StringNullableFilter<"Area"> | string | null
    createdAt?: DateTimeFilter<"Area"> | Date | string
    updatedAt?: DateTimeFilter<"Area"> | Date | string
    exams?: ExamRecordAreaListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exams?: ExamRecordAreaOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: number
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    name?: StringFilter<"Area"> | string
    slug?: StringNullableFilter<"Area"> | string | null
    createdAt?: DateTimeFilter<"Area"> | Date | string
    updatedAt?: DateTimeFilter<"Area"> | Date | string
    exams?: ExamRecordAreaListRelationFilter
  }, "id" | "externalId">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AreaCountOrderByAggregateInput
    _avg?: AreaAvgOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
    _sum?: AreaSumOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Area"> | string
    externalId?: IntWithAggregatesFilter<"Area"> | number
    name?: StringWithAggregatesFilter<"Area"> | string
    slug?: StringNullableWithAggregatesFilter<"Area"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Area"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Area"> | Date | string
  }

  export type ExamRecordWhereInput = {
    AND?: ExamRecordWhereInput | ExamRecordWhereInput[]
    OR?: ExamRecordWhereInput[]
    NOT?: ExamRecordWhereInput | ExamRecordWhereInput[]
    id?: StringFilter<"ExamRecord"> | string
    externalId?: IntFilter<"ExamRecord"> | number
    slug?: StringFilter<"ExamRecord"> | string
    name?: StringFilter<"ExamRecord"> | string
    type?: IntFilter<"ExamRecord"> | number
    year?: IntFilter<"ExamRecord"> | number
    level?: StringFilter<"ExamRecord"> | string
    questionCount?: IntFilter<"ExamRecord"> | number
    durationMinutes?: IntNullableFilter<"ExamRecord"> | number | null
    reviewed?: BoolFilter<"ExamRecord"> | boolean
    hasPendencies?: BoolFilter<"ExamRecord"> | boolean
    available?: BoolFilter<"ExamRecord"> | boolean
    observations?: StringNullableFilter<"ExamRecord"> | string | null
    otherData?: StringNullableFilter<"ExamRecord"> | string | null
    timestamp?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    applicationDate?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    examFileKey?: StringNullableFilter<"ExamRecord"> | string | null
    answerKeyFileKey?: StringNullableFilter<"ExamRecord"> | string | null
    organizationId?: StringFilter<"ExamRecord"> | string
    boardId?: StringFilter<"ExamRecord"> | string
    positionId?: StringFilter<"ExamRecord"> | string
    noticeId?: StringNullableFilter<"ExamRecord"> | string | null
    createdAt?: DateTimeFilter<"ExamRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ExamRecord"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
    notice?: XOR<NoticeNullableScalarRelationFilter, NoticeWhereInput> | null
    careers?: ExamRecordCareerListRelationFilter
    areas?: ExamRecordAreaListRelationFilter
    parts?: ExamRecordPartListRelationFilter
  }

  export type ExamRecordOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    level?: SortOrder
    questionCount?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    reviewed?: SortOrder
    hasPendencies?: SortOrder
    available?: SortOrder
    observations?: SortOrderInput | SortOrder
    otherData?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    applicationDate?: SortOrderInput | SortOrder
    examFileKey?: SortOrderInput | SortOrder
    answerKeyFileKey?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    boardId?: SortOrder
    positionId?: SortOrder
    noticeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    board?: BoardOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    notice?: NoticeOrderByWithRelationInput
    careers?: ExamRecordCareerOrderByRelationAggregateInput
    areas?: ExamRecordAreaOrderByRelationAggregateInput
    parts?: ExamRecordPartOrderByRelationAggregateInput
  }

  export type ExamRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId?: number
    slug?: string
    AND?: ExamRecordWhereInput | ExamRecordWhereInput[]
    OR?: ExamRecordWhereInput[]
    NOT?: ExamRecordWhereInput | ExamRecordWhereInput[]
    name?: StringFilter<"ExamRecord"> | string
    type?: IntFilter<"ExamRecord"> | number
    year?: IntFilter<"ExamRecord"> | number
    level?: StringFilter<"ExamRecord"> | string
    questionCount?: IntFilter<"ExamRecord"> | number
    durationMinutes?: IntNullableFilter<"ExamRecord"> | number | null
    reviewed?: BoolFilter<"ExamRecord"> | boolean
    hasPendencies?: BoolFilter<"ExamRecord"> | boolean
    available?: BoolFilter<"ExamRecord"> | boolean
    observations?: StringNullableFilter<"ExamRecord"> | string | null
    otherData?: StringNullableFilter<"ExamRecord"> | string | null
    timestamp?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    applicationDate?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    examFileKey?: StringNullableFilter<"ExamRecord"> | string | null
    answerKeyFileKey?: StringNullableFilter<"ExamRecord"> | string | null
    organizationId?: StringFilter<"ExamRecord"> | string
    boardId?: StringFilter<"ExamRecord"> | string
    positionId?: StringFilter<"ExamRecord"> | string
    noticeId?: StringNullableFilter<"ExamRecord"> | string | null
    createdAt?: DateTimeFilter<"ExamRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ExamRecord"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
    notice?: XOR<NoticeNullableScalarRelationFilter, NoticeWhereInput> | null
    careers?: ExamRecordCareerListRelationFilter
    areas?: ExamRecordAreaListRelationFilter
    parts?: ExamRecordPartListRelationFilter
  }, "id" | "externalId" | "slug">

  export type ExamRecordOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    level?: SortOrder
    questionCount?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    reviewed?: SortOrder
    hasPendencies?: SortOrder
    available?: SortOrder
    observations?: SortOrderInput | SortOrder
    otherData?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    applicationDate?: SortOrderInput | SortOrder
    examFileKey?: SortOrderInput | SortOrder
    answerKeyFileKey?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    boardId?: SortOrder
    positionId?: SortOrder
    noticeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamRecordCountOrderByAggregateInput
    _avg?: ExamRecordAvgOrderByAggregateInput
    _max?: ExamRecordMaxOrderByAggregateInput
    _min?: ExamRecordMinOrderByAggregateInput
    _sum?: ExamRecordSumOrderByAggregateInput
  }

  export type ExamRecordScalarWhereWithAggregatesInput = {
    AND?: ExamRecordScalarWhereWithAggregatesInput | ExamRecordScalarWhereWithAggregatesInput[]
    OR?: ExamRecordScalarWhereWithAggregatesInput[]
    NOT?: ExamRecordScalarWhereWithAggregatesInput | ExamRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamRecord"> | string
    externalId?: IntWithAggregatesFilter<"ExamRecord"> | number
    slug?: StringWithAggregatesFilter<"ExamRecord"> | string
    name?: StringWithAggregatesFilter<"ExamRecord"> | string
    type?: IntWithAggregatesFilter<"ExamRecord"> | number
    year?: IntWithAggregatesFilter<"ExamRecord"> | number
    level?: StringWithAggregatesFilter<"ExamRecord"> | string
    questionCount?: IntWithAggregatesFilter<"ExamRecord"> | number
    durationMinutes?: IntNullableWithAggregatesFilter<"ExamRecord"> | number | null
    reviewed?: BoolWithAggregatesFilter<"ExamRecord"> | boolean
    hasPendencies?: BoolWithAggregatesFilter<"ExamRecord"> | boolean
    available?: BoolWithAggregatesFilter<"ExamRecord"> | boolean
    observations?: StringNullableWithAggregatesFilter<"ExamRecord"> | string | null
    otherData?: StringNullableWithAggregatesFilter<"ExamRecord"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"ExamRecord"> | Date | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ExamRecord"> | Date | string | null
    applicationDate?: DateTimeNullableWithAggregatesFilter<"ExamRecord"> | Date | string | null
    examFileKey?: StringNullableWithAggregatesFilter<"ExamRecord"> | string | null
    answerKeyFileKey?: StringNullableWithAggregatesFilter<"ExamRecord"> | string | null
    organizationId?: StringWithAggregatesFilter<"ExamRecord"> | string
    boardId?: StringWithAggregatesFilter<"ExamRecord"> | string
    positionId?: StringWithAggregatesFilter<"ExamRecord"> | string
    noticeId?: StringNullableWithAggregatesFilter<"ExamRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExamRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamRecord"> | Date | string
  }

  export type ExamRecordCareerWhereInput = {
    AND?: ExamRecordCareerWhereInput | ExamRecordCareerWhereInput[]
    OR?: ExamRecordCareerWhereInput[]
    NOT?: ExamRecordCareerWhereInput | ExamRecordCareerWhereInput[]
    id?: StringFilter<"ExamRecordCareer"> | string
    examRecordId?: StringFilter<"ExamRecordCareer"> | string
    careerId?: StringFilter<"ExamRecordCareer"> | string
    examRecord?: XOR<ExamRecordScalarRelationFilter, ExamRecordWhereInput>
    career?: XOR<CareerScalarRelationFilter, CareerWhereInput>
  }

  export type ExamRecordCareerOrderByWithRelationInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    careerId?: SortOrder
    examRecord?: ExamRecordOrderByWithRelationInput
    career?: CareerOrderByWithRelationInput
  }

  export type ExamRecordCareerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    examRecordId_careerId?: ExamRecordCareerExamRecordIdCareerIdCompoundUniqueInput
    AND?: ExamRecordCareerWhereInput | ExamRecordCareerWhereInput[]
    OR?: ExamRecordCareerWhereInput[]
    NOT?: ExamRecordCareerWhereInput | ExamRecordCareerWhereInput[]
    examRecordId?: StringFilter<"ExamRecordCareer"> | string
    careerId?: StringFilter<"ExamRecordCareer"> | string
    examRecord?: XOR<ExamRecordScalarRelationFilter, ExamRecordWhereInput>
    career?: XOR<CareerScalarRelationFilter, CareerWhereInput>
  }, "id" | "examRecordId_careerId">

  export type ExamRecordCareerOrderByWithAggregationInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    careerId?: SortOrder
    _count?: ExamRecordCareerCountOrderByAggregateInput
    _max?: ExamRecordCareerMaxOrderByAggregateInput
    _min?: ExamRecordCareerMinOrderByAggregateInput
  }

  export type ExamRecordCareerScalarWhereWithAggregatesInput = {
    AND?: ExamRecordCareerScalarWhereWithAggregatesInput | ExamRecordCareerScalarWhereWithAggregatesInput[]
    OR?: ExamRecordCareerScalarWhereWithAggregatesInput[]
    NOT?: ExamRecordCareerScalarWhereWithAggregatesInput | ExamRecordCareerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamRecordCareer"> | string
    examRecordId?: StringWithAggregatesFilter<"ExamRecordCareer"> | string
    careerId?: StringWithAggregatesFilter<"ExamRecordCareer"> | string
  }

  export type ExamRecordAreaWhereInput = {
    AND?: ExamRecordAreaWhereInput | ExamRecordAreaWhereInput[]
    OR?: ExamRecordAreaWhereInput[]
    NOT?: ExamRecordAreaWhereInput | ExamRecordAreaWhereInput[]
    id?: StringFilter<"ExamRecordArea"> | string
    examRecordId?: StringFilter<"ExamRecordArea"> | string
    areaId?: StringFilter<"ExamRecordArea"> | string
    examRecord?: XOR<ExamRecordScalarRelationFilter, ExamRecordWhereInput>
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
  }

  export type ExamRecordAreaOrderByWithRelationInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    areaId?: SortOrder
    examRecord?: ExamRecordOrderByWithRelationInput
    area?: AreaOrderByWithRelationInput
  }

  export type ExamRecordAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    examRecordId_areaId?: ExamRecordAreaExamRecordIdAreaIdCompoundUniqueInput
    AND?: ExamRecordAreaWhereInput | ExamRecordAreaWhereInput[]
    OR?: ExamRecordAreaWhereInput[]
    NOT?: ExamRecordAreaWhereInput | ExamRecordAreaWhereInput[]
    examRecordId?: StringFilter<"ExamRecordArea"> | string
    areaId?: StringFilter<"ExamRecordArea"> | string
    examRecord?: XOR<ExamRecordScalarRelationFilter, ExamRecordWhereInput>
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
  }, "id" | "examRecordId_areaId">

  export type ExamRecordAreaOrderByWithAggregationInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    areaId?: SortOrder
    _count?: ExamRecordAreaCountOrderByAggregateInput
    _max?: ExamRecordAreaMaxOrderByAggregateInput
    _min?: ExamRecordAreaMinOrderByAggregateInput
  }

  export type ExamRecordAreaScalarWhereWithAggregatesInput = {
    AND?: ExamRecordAreaScalarWhereWithAggregatesInput | ExamRecordAreaScalarWhereWithAggregatesInput[]
    OR?: ExamRecordAreaScalarWhereWithAggregatesInput[]
    NOT?: ExamRecordAreaScalarWhereWithAggregatesInput | ExamRecordAreaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamRecordArea"> | string
    examRecordId?: StringWithAggregatesFilter<"ExamRecordArea"> | string
    areaId?: StringWithAggregatesFilter<"ExamRecordArea"> | string
  }

  export type ExamRecordPartWhereInput = {
    AND?: ExamRecordPartWhereInput | ExamRecordPartWhereInput[]
    OR?: ExamRecordPartWhereInput[]
    NOT?: ExamRecordPartWhereInput | ExamRecordPartWhereInput[]
    id?: StringFilter<"ExamRecordPart"> | string
    examRecordId?: StringFilter<"ExamRecordPart"> | string
    externalId?: IntNullableFilter<"ExamRecordPart"> | number | null
    description?: StringFilter<"ExamRecordPart"> | string
    examRecord?: XOR<ExamRecordScalarRelationFilter, ExamRecordWhereInput>
  }

  export type ExamRecordPartOrderByWithRelationInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    description?: SortOrder
    examRecord?: ExamRecordOrderByWithRelationInput
  }

  export type ExamRecordPartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamRecordPartWhereInput | ExamRecordPartWhereInput[]
    OR?: ExamRecordPartWhereInput[]
    NOT?: ExamRecordPartWhereInput | ExamRecordPartWhereInput[]
    examRecordId?: StringFilter<"ExamRecordPart"> | string
    externalId?: IntNullableFilter<"ExamRecordPart"> | number | null
    description?: StringFilter<"ExamRecordPart"> | string
    examRecord?: XOR<ExamRecordScalarRelationFilter, ExamRecordWhereInput>
  }, "id">

  export type ExamRecordPartOrderByWithAggregationInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    description?: SortOrder
    _count?: ExamRecordPartCountOrderByAggregateInput
    _avg?: ExamRecordPartAvgOrderByAggregateInput
    _max?: ExamRecordPartMaxOrderByAggregateInput
    _min?: ExamRecordPartMinOrderByAggregateInput
    _sum?: ExamRecordPartSumOrderByAggregateInput
  }

  export type ExamRecordPartScalarWhereWithAggregatesInput = {
    AND?: ExamRecordPartScalarWhereWithAggregatesInput | ExamRecordPartScalarWhereWithAggregatesInput[]
    OR?: ExamRecordPartScalarWhereWithAggregatesInput[]
    NOT?: ExamRecordPartScalarWhereWithAggregatesInput | ExamRecordPartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamRecordPart"> | string
    examRecordId?: StringWithAggregatesFilter<"ExamRecordPart"> | string
    externalId?: IntNullableWithAggregatesFilter<"ExamRecordPart"> | number | null
    description?: StringWithAggregatesFilter<"ExamRecordPart"> | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    year: number
    organization: string
    institution: string
    level: string
    sourceUrl?: string | null
    examPdfUrl?: string | null
    answerKeyUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    year: number
    organization: string
    institution: string
    level: string
    sourceUrl?: string | null
    examPdfUrl?: string | null
    answerKeyUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    organization?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    examPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    organization?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    examPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    year: number
    organization: string
    institution: string
    level: string
    sourceUrl?: string | null
    examPdfUrl?: string | null
    answerKeyUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    organization?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    examPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    organization?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    examPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exam?: ExamCreateNestedOneWithoutQuestionsInput
    alternatives?: AlternativeCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    examId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneWithoutQuestionsNestedInput
    alternatives?: AlternativeUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    examId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeCreateInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutAlternativesInput
  }

  export type AlternativeUncheckedCreateInput = {
    id?: string
    text: string
    isCorrect?: boolean
    questionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAlternativesNestedInput
  }

  export type AlternativeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeCreateManyInput = {
    id?: string
    text: string
    isCorrect?: boolean
    questionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    questionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationCreateInput = {
    id?: string
    studentId: string
    title: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
    answers?: SimulationAnswerCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateInput = {
    id?: string
    studentId: string
    title: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
    answers?: SimulationAnswerUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: SimulationAnswerUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: SimulationAnswerUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationCreateManyInput = {
    id?: string
    studentId: string
    title: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type SimulationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimulationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimulationAnswerCreateInput = {
    id?: string
    questionId: string
    alternativeId: string
    createdAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutAnswersInput
  }

  export type SimulationAnswerUncheckedCreateInput = {
    id?: string
    simulationId: string
    questionId: string
    alternativeId: string
    createdAt?: Date | string
  }

  export type SimulationAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type SimulationAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationAnswerCreateManyInput = {
    id?: string
    simulationId: string
    questionId: string
    alternativeId: string
    createdAt?: Date | string
  }

  export type SimulationAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    externalId: number
    name: string
    acronym?: string | null
    sphere?: string | null
    state?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    externalId: number
    name: string
    acronym?: string | null
    sphere?: string | null
    state?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    sphere?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    sphere?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    externalId: number
    name: string
    acronym?: string | null
    sphere?: string | null
    state?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    sphere?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    sphere?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardCreateInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    acronym?: string | null
    isOab?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    acronym?: string | null
    isOab?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    isOab?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    isOab?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    acronym?: string | null
    isOab?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    isOab?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    isOab?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeCreateInput = {
    id?: string
    externalId: number
    slug?: string | null
    enrollmentStart?: Date | string | null
    enrollmentEnd?: Date | string | null
    plannedApplication?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordCreateNestedManyWithoutNoticeInput
  }

  export type NoticeUncheckedCreateInput = {
    id?: string
    externalId: number
    slug?: string | null
    enrollmentStart?: Date | string | null
    enrollmentEnd?: Date | string | null
    plannedApplication?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examRecords?: ExamRecordUncheckedCreateNestedManyWithoutNoticeInput
  }

  export type NoticeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedApplication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUpdateManyWithoutNoticeNestedInput
  }

  export type NoticeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedApplication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examRecords?: ExamRecordUncheckedUpdateManyWithoutNoticeNestedInput
  }

  export type NoticeCreateManyInput = {
    id?: string
    externalId: number
    slug?: string | null
    enrollmentStart?: Date | string | null
    enrollmentEnd?: Date | string | null
    plannedApplication?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedApplication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedApplication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerCreateInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamRecordCareerCreateNestedManyWithoutCareerInput
  }

  export type CareerUncheckedCreateInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamRecordCareerUncheckedCreateNestedManyWithoutCareerInput
  }

  export type CareerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamRecordCareerUpdateManyWithoutCareerNestedInput
  }

  export type CareerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamRecordCareerUncheckedUpdateManyWithoutCareerNestedInput
  }

  export type CareerCreateManyInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaCreateInput = {
    id?: string
    externalId: number
    name: string
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamRecordAreaCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: string
    externalId: number
    name: string
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamRecordAreaUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamRecordAreaUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamRecordAreaUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: string
    externalId: number
    name: string
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AreaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCreateInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutExamRecordsInput
    board: BoardCreateNestedOneWithoutExamRecordsInput
    position: PositionCreateNestedOneWithoutExamRecordsInput
    notice?: NoticeCreateNestedOneWithoutExamRecordsInput
    careers?: ExamRecordCareerCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    careers?: ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput
    board?: BoardUpdateOneRequiredWithoutExamRecordsNestedInput
    position?: PositionUpdateOneRequiredWithoutExamRecordsNestedInput
    notice?: NoticeUpdateOneWithoutExamRecordsNestedInput
    careers?: ExamRecordCareerUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careers?: ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordCreateManyInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCareerCreateInput = {
    id?: string
    examRecord: ExamRecordCreateNestedOneWithoutCareersInput
    career: CareerCreateNestedOneWithoutExamsInput
  }

  export type ExamRecordCareerUncheckedCreateInput = {
    id?: string
    examRecordId: string
    careerId: string
  }

  export type ExamRecordCareerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecord?: ExamRecordUpdateOneRequiredWithoutCareersNestedInput
    career?: CareerUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamRecordCareerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordCareerCreateManyInput = {
    id?: string
    examRecordId: string
    careerId: string
  }

  export type ExamRecordCareerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordCareerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordAreaCreateInput = {
    id?: string
    examRecord: ExamRecordCreateNestedOneWithoutAreasInput
    area: AreaCreateNestedOneWithoutExamsInput
  }

  export type ExamRecordAreaUncheckedCreateInput = {
    id?: string
    examRecordId: string
    areaId: string
  }

  export type ExamRecordAreaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecord?: ExamRecordUpdateOneRequiredWithoutAreasNestedInput
    area?: AreaUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamRecordAreaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordAreaCreateManyInput = {
    id?: string
    examRecordId: string
    areaId: string
  }

  export type ExamRecordAreaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordAreaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordPartCreateInput = {
    id?: string
    externalId?: number | null
    description: string
    examRecord: ExamRecordCreateNestedOneWithoutPartsInput
  }

  export type ExamRecordPartUncheckedCreateInput = {
    id?: string
    examRecordId: string
    externalId?: number | null
    description: string
  }

  export type ExamRecordPartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    examRecord?: ExamRecordUpdateOneRequiredWithoutPartsNestedInput
  }

  export type ExamRecordPartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordPartCreateManyInput = {
    id?: string
    examRecordId: string
    externalId?: number | null
    description: string
  }

  export type ExamRecordPartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordPartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
    externalId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    organization?: SortOrder
    institution?: SortOrder
    level?: SortOrder
    sourceUrl?: SortOrder
    examPdfUrl?: SortOrder
    answerKeyUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    organization?: SortOrder
    institution?: SortOrder
    level?: SortOrder
    sourceUrl?: SortOrder
    examPdfUrl?: SortOrder
    answerKeyUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    organization?: SortOrder
    institution?: SortOrder
    level?: SortOrder
    sourceUrl?: SortOrder
    examPdfUrl?: SortOrder
    answerKeyUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ExamNullableScalarRelationFilter = {
    is?: ExamWhereInput | null
    isNot?: ExamWhereInput | null
  }

  export type AlternativeListRelationFilter = {
    every?: AlternativeWhereInput
    some?: AlternativeWhereInput
    none?: AlternativeWhereInput
  }

  export type AlternativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    statement?: SortOrder
    organization?: SortOrder
    subject?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    statement?: SortOrder
    organization?: SortOrder
    subject?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    statement?: SortOrder
    organization?: SortOrder
    subject?: SortOrder
    examId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type AlternativeCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlternativeMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlternativeMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SimulationAnswerListRelationFilter = {
    every?: SimulationAnswerWhereInput
    some?: SimulationAnswerWhereInput
    none?: SimulationAnswerWhereInput
  }

  export type SimulationAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimulationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type SimulationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type SimulationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SimulationScalarRelationFilter = {
    is?: SimulationWhereInput
    isNot?: SimulationWhereInput
  }

  export type SimulationAnswerSimulationIdQuestionIdCompoundUniqueInput = {
    simulationId: string
    questionId: string
  }

  export type SimulationAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
    createdAt?: SortOrder
  }

  export type SimulationAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
    createdAt?: SortOrder
  }

  export type SimulationAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamRecordListRelationFilter = {
    every?: ExamRecordWhereInput
    some?: ExamRecordWhereInput
    none?: ExamRecordWhereInput
  }

  export type ExamRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    acronym?: SortOrder
    sphere?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    acronym?: SortOrder
    sphere?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    acronym?: SortOrder
    sphere?: SortOrder
    state?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    acronym?: SortOrder
    isOab?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoardAvgOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    acronym?: SortOrder
    isOab?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    acronym?: SortOrder
    isOab?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoardSumOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    enrollmentStart?: SortOrder
    enrollmentEnd?: SortOrder
    plannedApplication?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    enrollmentStart?: SortOrder
    enrollmentEnd?: SortOrder
    plannedApplication?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    enrollmentStart?: SortOrder
    enrollmentEnd?: SortOrder
    plannedApplication?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type ExamRecordCareerListRelationFilter = {
    every?: ExamRecordCareerWhereInput
    some?: ExamRecordCareerWhereInput
    none?: ExamRecordCareerWhereInput
  }

  export type ExamRecordCareerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CareerCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerAvgOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type CareerMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerSumOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type ExamRecordAreaListRelationFilter = {
    every?: ExamRecordAreaWhereInput
    some?: ExamRecordAreaWhereInput
    none?: ExamRecordAreaWhereInput
  }

  export type ExamRecordAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AreaAvgOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AreaSumOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type BoardScalarRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type PositionScalarRelationFilter = {
    is?: PositionWhereInput
    isNot?: PositionWhereInput
  }

  export type NoticeNullableScalarRelationFilter = {
    is?: NoticeWhereInput | null
    isNot?: NoticeWhereInput | null
  }

  export type ExamRecordPartListRelationFilter = {
    every?: ExamRecordPartWhereInput
    some?: ExamRecordPartWhereInput
    none?: ExamRecordPartWhereInput
  }

  export type ExamRecordPartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamRecordCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    level?: SortOrder
    questionCount?: SortOrder
    durationMinutes?: SortOrder
    reviewed?: SortOrder
    hasPendencies?: SortOrder
    available?: SortOrder
    observations?: SortOrder
    otherData?: SortOrder
    timestamp?: SortOrder
    publishedAt?: SortOrder
    applicationDate?: SortOrder
    examFileKey?: SortOrder
    answerKeyFileKey?: SortOrder
    organizationId?: SortOrder
    boardId?: SortOrder
    positionId?: SortOrder
    noticeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamRecordAvgOrderByAggregateInput = {
    externalId?: SortOrder
    type?: SortOrder
    year?: SortOrder
    questionCount?: SortOrder
    durationMinutes?: SortOrder
  }

  export type ExamRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    level?: SortOrder
    questionCount?: SortOrder
    durationMinutes?: SortOrder
    reviewed?: SortOrder
    hasPendencies?: SortOrder
    available?: SortOrder
    observations?: SortOrder
    otherData?: SortOrder
    timestamp?: SortOrder
    publishedAt?: SortOrder
    applicationDate?: SortOrder
    examFileKey?: SortOrder
    answerKeyFileKey?: SortOrder
    organizationId?: SortOrder
    boardId?: SortOrder
    positionId?: SortOrder
    noticeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamRecordMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    level?: SortOrder
    questionCount?: SortOrder
    durationMinutes?: SortOrder
    reviewed?: SortOrder
    hasPendencies?: SortOrder
    available?: SortOrder
    observations?: SortOrder
    otherData?: SortOrder
    timestamp?: SortOrder
    publishedAt?: SortOrder
    applicationDate?: SortOrder
    examFileKey?: SortOrder
    answerKeyFileKey?: SortOrder
    organizationId?: SortOrder
    boardId?: SortOrder
    positionId?: SortOrder
    noticeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamRecordSumOrderByAggregateInput = {
    externalId?: SortOrder
    type?: SortOrder
    year?: SortOrder
    questionCount?: SortOrder
    durationMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ExamRecordScalarRelationFilter = {
    is?: ExamRecordWhereInput
    isNot?: ExamRecordWhereInput
  }

  export type CareerScalarRelationFilter = {
    is?: CareerWhereInput
    isNot?: CareerWhereInput
  }

  export type ExamRecordCareerExamRecordIdCareerIdCompoundUniqueInput = {
    examRecordId: string
    careerId: string
  }

  export type ExamRecordCareerCountOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    careerId?: SortOrder
  }

  export type ExamRecordCareerMaxOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    careerId?: SortOrder
  }

  export type ExamRecordCareerMinOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    careerId?: SortOrder
  }

  export type AreaScalarRelationFilter = {
    is?: AreaWhereInput
    isNot?: AreaWhereInput
  }

  export type ExamRecordAreaExamRecordIdAreaIdCompoundUniqueInput = {
    examRecordId: string
    areaId: string
  }

  export type ExamRecordAreaCountOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    areaId?: SortOrder
  }

  export type ExamRecordAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    areaId?: SortOrder
  }

  export type ExamRecordAreaMinOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    areaId?: SortOrder
  }

  export type ExamRecordPartCountOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    externalId?: SortOrder
    description?: SortOrder
  }

  export type ExamRecordPartAvgOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type ExamRecordPartMaxOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    externalId?: SortOrder
    description?: SortOrder
  }

  export type ExamRecordPartMinOrderByAggregateInput = {
    id?: SortOrder
    examRecordId?: SortOrder
    externalId?: SortOrder
    description?: SortOrder
  }

  export type ExamRecordPartSumOrderByAggregateInput = {
    externalId?: SortOrder
  }

  export type QuestionCreateNestedManyWithoutExamInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type QuestionUpdateManyWithoutExamNestedInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutExamInput | QuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutExamInput | QuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutExamInput | QuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput> | QuestionCreateWithoutExamInput[] | QuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamInput | QuestionCreateOrConnectWithoutExamInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutExamInput | QuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: QuestionCreateManyExamInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutExamInput | QuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutExamInput | QuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ExamCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    connect?: ExamWhereUniqueInput
  }

  export type AlternativeCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
  }

  export type AlternativeUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
  }

  export type ExamUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    upsert?: ExamUpsertWithoutQuestionsInput
    disconnect?: ExamWhereInput | boolean
    delete?: ExamWhereInput | boolean
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutQuestionsInput, ExamUpdateWithoutQuestionsInput>, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type AlternativeUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    upsert?: AlternativeUpsertWithWhereUniqueWithoutQuestionInput | AlternativeUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    set?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    disconnect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    delete?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    update?: AlternativeUpdateWithWhereUniqueWithoutQuestionInput | AlternativeUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AlternativeUpdateManyWithWhereWithoutQuestionInput | AlternativeUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
  }

  export type AlternativeUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    upsert?: AlternativeUpsertWithWhereUniqueWithoutQuestionInput | AlternativeUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    set?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    disconnect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    delete?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    update?: AlternativeUpdateWithWhereUniqueWithoutQuestionInput | AlternativeUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AlternativeUpdateManyWithWhereWithoutQuestionInput | AlternativeUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutAlternativesInput = {
    create?: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAlternativesInput
    connect?: QuestionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type QuestionUpdateOneRequiredWithoutAlternativesNestedInput = {
    create?: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAlternativesInput
    upsert?: QuestionUpsertWithoutAlternativesInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutAlternativesInput, QuestionUpdateWithoutAlternativesInput>, QuestionUncheckedUpdateWithoutAlternativesInput>
  }

  export type SimulationAnswerCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationAnswerCreateWithoutSimulationInput, SimulationAnswerUncheckedCreateWithoutSimulationInput> | SimulationAnswerCreateWithoutSimulationInput[] | SimulationAnswerUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationAnswerCreateOrConnectWithoutSimulationInput | SimulationAnswerCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationAnswerCreateManySimulationInputEnvelope
    connect?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
  }

  export type SimulationAnswerUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationAnswerCreateWithoutSimulationInput, SimulationAnswerUncheckedCreateWithoutSimulationInput> | SimulationAnswerCreateWithoutSimulationInput[] | SimulationAnswerUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationAnswerCreateOrConnectWithoutSimulationInput | SimulationAnswerCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationAnswerCreateManySimulationInputEnvelope
    connect?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SimulationAnswerUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationAnswerCreateWithoutSimulationInput, SimulationAnswerUncheckedCreateWithoutSimulationInput> | SimulationAnswerCreateWithoutSimulationInput[] | SimulationAnswerUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationAnswerCreateOrConnectWithoutSimulationInput | SimulationAnswerCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationAnswerUpsertWithWhereUniqueWithoutSimulationInput | SimulationAnswerUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationAnswerCreateManySimulationInputEnvelope
    set?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    disconnect?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    delete?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    connect?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    update?: SimulationAnswerUpdateWithWhereUniqueWithoutSimulationInput | SimulationAnswerUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationAnswerUpdateManyWithWhereWithoutSimulationInput | SimulationAnswerUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationAnswerScalarWhereInput | SimulationAnswerScalarWhereInput[]
  }

  export type SimulationAnswerUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationAnswerCreateWithoutSimulationInput, SimulationAnswerUncheckedCreateWithoutSimulationInput> | SimulationAnswerCreateWithoutSimulationInput[] | SimulationAnswerUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationAnswerCreateOrConnectWithoutSimulationInput | SimulationAnswerCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationAnswerUpsertWithWhereUniqueWithoutSimulationInput | SimulationAnswerUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationAnswerCreateManySimulationInputEnvelope
    set?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    disconnect?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    delete?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    connect?: SimulationAnswerWhereUniqueInput | SimulationAnswerWhereUniqueInput[]
    update?: SimulationAnswerUpdateWithWhereUniqueWithoutSimulationInput | SimulationAnswerUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationAnswerUpdateManyWithWhereWithoutSimulationInput | SimulationAnswerUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationAnswerScalarWhereInput | SimulationAnswerScalarWhereInput[]
  }

  export type SimulationCreateNestedOneWithoutAnswersInput = {
    create?: XOR<SimulationCreateWithoutAnswersInput, SimulationUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutAnswersInput
    connect?: SimulationWhereUniqueInput
  }

  export type SimulationUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<SimulationCreateWithoutAnswersInput, SimulationUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutAnswersInput
    upsert?: SimulationUpsertWithoutAnswersInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutAnswersInput, SimulationUpdateWithoutAnswersInput>, SimulationUncheckedUpdateWithoutAnswersInput>
  }

  export type ExamRecordCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ExamRecordCreateWithoutOrganizationInput, ExamRecordUncheckedCreateWithoutOrganizationInput> | ExamRecordCreateWithoutOrganizationInput[] | ExamRecordUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutOrganizationInput | ExamRecordCreateOrConnectWithoutOrganizationInput[]
    createMany?: ExamRecordCreateManyOrganizationInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ExamRecordCreateWithoutOrganizationInput, ExamRecordUncheckedCreateWithoutOrganizationInput> | ExamRecordCreateWithoutOrganizationInput[] | ExamRecordUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutOrganizationInput | ExamRecordCreateOrConnectWithoutOrganizationInput[]
    createMany?: ExamRecordCreateManyOrganizationInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ExamRecordCreateWithoutOrganizationInput, ExamRecordUncheckedCreateWithoutOrganizationInput> | ExamRecordCreateWithoutOrganizationInput[] | ExamRecordUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutOrganizationInput | ExamRecordCreateOrConnectWithoutOrganizationInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutOrganizationInput | ExamRecordUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ExamRecordCreateManyOrganizationInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutOrganizationInput | ExamRecordUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutOrganizationInput | ExamRecordUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ExamRecordCreateWithoutOrganizationInput, ExamRecordUncheckedCreateWithoutOrganizationInput> | ExamRecordCreateWithoutOrganizationInput[] | ExamRecordUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutOrganizationInput | ExamRecordCreateOrConnectWithoutOrganizationInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutOrganizationInput | ExamRecordUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ExamRecordCreateManyOrganizationInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutOrganizationInput | ExamRecordUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutOrganizationInput | ExamRecordUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordCreateNestedManyWithoutBoardInput = {
    create?: XOR<ExamRecordCreateWithoutBoardInput, ExamRecordUncheckedCreateWithoutBoardInput> | ExamRecordCreateWithoutBoardInput[] | ExamRecordUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutBoardInput | ExamRecordCreateOrConnectWithoutBoardInput[]
    createMany?: ExamRecordCreateManyBoardInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<ExamRecordCreateWithoutBoardInput, ExamRecordUncheckedCreateWithoutBoardInput> | ExamRecordCreateWithoutBoardInput[] | ExamRecordUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutBoardInput | ExamRecordCreateOrConnectWithoutBoardInput[]
    createMany?: ExamRecordCreateManyBoardInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ExamRecordCreateWithoutBoardInput, ExamRecordUncheckedCreateWithoutBoardInput> | ExamRecordCreateWithoutBoardInput[] | ExamRecordUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutBoardInput | ExamRecordCreateOrConnectWithoutBoardInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutBoardInput | ExamRecordUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ExamRecordCreateManyBoardInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutBoardInput | ExamRecordUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutBoardInput | ExamRecordUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<ExamRecordCreateWithoutBoardInput, ExamRecordUncheckedCreateWithoutBoardInput> | ExamRecordCreateWithoutBoardInput[] | ExamRecordUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutBoardInput | ExamRecordCreateOrConnectWithoutBoardInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutBoardInput | ExamRecordUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: ExamRecordCreateManyBoardInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutBoardInput | ExamRecordUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutBoardInput | ExamRecordUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordCreateNestedManyWithoutPositionInput = {
    create?: XOR<ExamRecordCreateWithoutPositionInput, ExamRecordUncheckedCreateWithoutPositionInput> | ExamRecordCreateWithoutPositionInput[] | ExamRecordUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutPositionInput | ExamRecordCreateOrConnectWithoutPositionInput[]
    createMany?: ExamRecordCreateManyPositionInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<ExamRecordCreateWithoutPositionInput, ExamRecordUncheckedCreateWithoutPositionInput> | ExamRecordCreateWithoutPositionInput[] | ExamRecordUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutPositionInput | ExamRecordCreateOrConnectWithoutPositionInput[]
    createMany?: ExamRecordCreateManyPositionInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUpdateManyWithoutPositionNestedInput = {
    create?: XOR<ExamRecordCreateWithoutPositionInput, ExamRecordUncheckedCreateWithoutPositionInput> | ExamRecordCreateWithoutPositionInput[] | ExamRecordUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutPositionInput | ExamRecordCreateOrConnectWithoutPositionInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutPositionInput | ExamRecordUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: ExamRecordCreateManyPositionInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutPositionInput | ExamRecordUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutPositionInput | ExamRecordUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<ExamRecordCreateWithoutPositionInput, ExamRecordUncheckedCreateWithoutPositionInput> | ExamRecordCreateWithoutPositionInput[] | ExamRecordUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutPositionInput | ExamRecordCreateOrConnectWithoutPositionInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutPositionInput | ExamRecordUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: ExamRecordCreateManyPositionInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutPositionInput | ExamRecordUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutPositionInput | ExamRecordUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordCreateNestedManyWithoutNoticeInput = {
    create?: XOR<ExamRecordCreateWithoutNoticeInput, ExamRecordUncheckedCreateWithoutNoticeInput> | ExamRecordCreateWithoutNoticeInput[] | ExamRecordUncheckedCreateWithoutNoticeInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutNoticeInput | ExamRecordCreateOrConnectWithoutNoticeInput[]
    createMany?: ExamRecordCreateManyNoticeInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUncheckedCreateNestedManyWithoutNoticeInput = {
    create?: XOR<ExamRecordCreateWithoutNoticeInput, ExamRecordUncheckedCreateWithoutNoticeInput> | ExamRecordCreateWithoutNoticeInput[] | ExamRecordUncheckedCreateWithoutNoticeInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutNoticeInput | ExamRecordCreateOrConnectWithoutNoticeInput[]
    createMany?: ExamRecordCreateManyNoticeInputEnvelope
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
  }

  export type ExamRecordUpdateManyWithoutNoticeNestedInput = {
    create?: XOR<ExamRecordCreateWithoutNoticeInput, ExamRecordUncheckedCreateWithoutNoticeInput> | ExamRecordCreateWithoutNoticeInput[] | ExamRecordUncheckedCreateWithoutNoticeInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutNoticeInput | ExamRecordCreateOrConnectWithoutNoticeInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutNoticeInput | ExamRecordUpsertWithWhereUniqueWithoutNoticeInput[]
    createMany?: ExamRecordCreateManyNoticeInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutNoticeInput | ExamRecordUpdateWithWhereUniqueWithoutNoticeInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutNoticeInput | ExamRecordUpdateManyWithWhereWithoutNoticeInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordUncheckedUpdateManyWithoutNoticeNestedInput = {
    create?: XOR<ExamRecordCreateWithoutNoticeInput, ExamRecordUncheckedCreateWithoutNoticeInput> | ExamRecordCreateWithoutNoticeInput[] | ExamRecordUncheckedCreateWithoutNoticeInput[]
    connectOrCreate?: ExamRecordCreateOrConnectWithoutNoticeInput | ExamRecordCreateOrConnectWithoutNoticeInput[]
    upsert?: ExamRecordUpsertWithWhereUniqueWithoutNoticeInput | ExamRecordUpsertWithWhereUniqueWithoutNoticeInput[]
    createMany?: ExamRecordCreateManyNoticeInputEnvelope
    set?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    disconnect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    delete?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    connect?: ExamRecordWhereUniqueInput | ExamRecordWhereUniqueInput[]
    update?: ExamRecordUpdateWithWhereUniqueWithoutNoticeInput | ExamRecordUpdateWithWhereUniqueWithoutNoticeInput[]
    updateMany?: ExamRecordUpdateManyWithWhereWithoutNoticeInput | ExamRecordUpdateManyWithWhereWithoutNoticeInput[]
    deleteMany?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
  }

  export type ExamRecordCareerCreateNestedManyWithoutCareerInput = {
    create?: XOR<ExamRecordCareerCreateWithoutCareerInput, ExamRecordCareerUncheckedCreateWithoutCareerInput> | ExamRecordCareerCreateWithoutCareerInput[] | ExamRecordCareerUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutCareerInput | ExamRecordCareerCreateOrConnectWithoutCareerInput[]
    createMany?: ExamRecordCareerCreateManyCareerInputEnvelope
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
  }

  export type ExamRecordCareerUncheckedCreateNestedManyWithoutCareerInput = {
    create?: XOR<ExamRecordCareerCreateWithoutCareerInput, ExamRecordCareerUncheckedCreateWithoutCareerInput> | ExamRecordCareerCreateWithoutCareerInput[] | ExamRecordCareerUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutCareerInput | ExamRecordCareerCreateOrConnectWithoutCareerInput[]
    createMany?: ExamRecordCareerCreateManyCareerInputEnvelope
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
  }

  export type ExamRecordCareerUpdateManyWithoutCareerNestedInput = {
    create?: XOR<ExamRecordCareerCreateWithoutCareerInput, ExamRecordCareerUncheckedCreateWithoutCareerInput> | ExamRecordCareerCreateWithoutCareerInput[] | ExamRecordCareerUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutCareerInput | ExamRecordCareerCreateOrConnectWithoutCareerInput[]
    upsert?: ExamRecordCareerUpsertWithWhereUniqueWithoutCareerInput | ExamRecordCareerUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: ExamRecordCareerCreateManyCareerInputEnvelope
    set?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    disconnect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    delete?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    update?: ExamRecordCareerUpdateWithWhereUniqueWithoutCareerInput | ExamRecordCareerUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: ExamRecordCareerUpdateManyWithWhereWithoutCareerInput | ExamRecordCareerUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: ExamRecordCareerScalarWhereInput | ExamRecordCareerScalarWhereInput[]
  }

  export type ExamRecordCareerUncheckedUpdateManyWithoutCareerNestedInput = {
    create?: XOR<ExamRecordCareerCreateWithoutCareerInput, ExamRecordCareerUncheckedCreateWithoutCareerInput> | ExamRecordCareerCreateWithoutCareerInput[] | ExamRecordCareerUncheckedCreateWithoutCareerInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutCareerInput | ExamRecordCareerCreateOrConnectWithoutCareerInput[]
    upsert?: ExamRecordCareerUpsertWithWhereUniqueWithoutCareerInput | ExamRecordCareerUpsertWithWhereUniqueWithoutCareerInput[]
    createMany?: ExamRecordCareerCreateManyCareerInputEnvelope
    set?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    disconnect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    delete?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    update?: ExamRecordCareerUpdateWithWhereUniqueWithoutCareerInput | ExamRecordCareerUpdateWithWhereUniqueWithoutCareerInput[]
    updateMany?: ExamRecordCareerUpdateManyWithWhereWithoutCareerInput | ExamRecordCareerUpdateManyWithWhereWithoutCareerInput[]
    deleteMany?: ExamRecordCareerScalarWhereInput | ExamRecordCareerScalarWhereInput[]
  }

  export type ExamRecordAreaCreateNestedManyWithoutAreaInput = {
    create?: XOR<ExamRecordAreaCreateWithoutAreaInput, ExamRecordAreaUncheckedCreateWithoutAreaInput> | ExamRecordAreaCreateWithoutAreaInput[] | ExamRecordAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutAreaInput | ExamRecordAreaCreateOrConnectWithoutAreaInput[]
    createMany?: ExamRecordAreaCreateManyAreaInputEnvelope
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
  }

  export type ExamRecordAreaUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<ExamRecordAreaCreateWithoutAreaInput, ExamRecordAreaUncheckedCreateWithoutAreaInput> | ExamRecordAreaCreateWithoutAreaInput[] | ExamRecordAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutAreaInput | ExamRecordAreaCreateOrConnectWithoutAreaInput[]
    createMany?: ExamRecordAreaCreateManyAreaInputEnvelope
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
  }

  export type ExamRecordAreaUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ExamRecordAreaCreateWithoutAreaInput, ExamRecordAreaUncheckedCreateWithoutAreaInput> | ExamRecordAreaCreateWithoutAreaInput[] | ExamRecordAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutAreaInput | ExamRecordAreaCreateOrConnectWithoutAreaInput[]
    upsert?: ExamRecordAreaUpsertWithWhereUniqueWithoutAreaInput | ExamRecordAreaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ExamRecordAreaCreateManyAreaInputEnvelope
    set?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    disconnect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    delete?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    update?: ExamRecordAreaUpdateWithWhereUniqueWithoutAreaInput | ExamRecordAreaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ExamRecordAreaUpdateManyWithWhereWithoutAreaInput | ExamRecordAreaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ExamRecordAreaScalarWhereInput | ExamRecordAreaScalarWhereInput[]
  }

  export type ExamRecordAreaUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ExamRecordAreaCreateWithoutAreaInput, ExamRecordAreaUncheckedCreateWithoutAreaInput> | ExamRecordAreaCreateWithoutAreaInput[] | ExamRecordAreaUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutAreaInput | ExamRecordAreaCreateOrConnectWithoutAreaInput[]
    upsert?: ExamRecordAreaUpsertWithWhereUniqueWithoutAreaInput | ExamRecordAreaUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ExamRecordAreaCreateManyAreaInputEnvelope
    set?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    disconnect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    delete?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    update?: ExamRecordAreaUpdateWithWhereUniqueWithoutAreaInput | ExamRecordAreaUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ExamRecordAreaUpdateManyWithWhereWithoutAreaInput | ExamRecordAreaUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ExamRecordAreaScalarWhereInput | ExamRecordAreaScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutExamRecordsInput = {
    create?: XOR<OrganizationCreateWithoutExamRecordsInput, OrganizationUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutExamRecordsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type BoardCreateNestedOneWithoutExamRecordsInput = {
    create?: XOR<BoardCreateWithoutExamRecordsInput, BoardUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutExamRecordsInput
    connect?: BoardWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutExamRecordsInput = {
    create?: XOR<PositionCreateWithoutExamRecordsInput, PositionUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: PositionCreateOrConnectWithoutExamRecordsInput
    connect?: PositionWhereUniqueInput
  }

  export type NoticeCreateNestedOneWithoutExamRecordsInput = {
    create?: XOR<NoticeCreateWithoutExamRecordsInput, NoticeUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: NoticeCreateOrConnectWithoutExamRecordsInput
    connect?: NoticeWhereUniqueInput
  }

  export type ExamRecordCareerCreateNestedManyWithoutExamRecordInput = {
    create?: XOR<ExamRecordCareerCreateWithoutExamRecordInput, ExamRecordCareerUncheckedCreateWithoutExamRecordInput> | ExamRecordCareerCreateWithoutExamRecordInput[] | ExamRecordCareerUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutExamRecordInput | ExamRecordCareerCreateOrConnectWithoutExamRecordInput[]
    createMany?: ExamRecordCareerCreateManyExamRecordInputEnvelope
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
  }

  export type ExamRecordAreaCreateNestedManyWithoutExamRecordInput = {
    create?: XOR<ExamRecordAreaCreateWithoutExamRecordInput, ExamRecordAreaUncheckedCreateWithoutExamRecordInput> | ExamRecordAreaCreateWithoutExamRecordInput[] | ExamRecordAreaUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutExamRecordInput | ExamRecordAreaCreateOrConnectWithoutExamRecordInput[]
    createMany?: ExamRecordAreaCreateManyExamRecordInputEnvelope
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
  }

  export type ExamRecordPartCreateNestedManyWithoutExamRecordInput = {
    create?: XOR<ExamRecordPartCreateWithoutExamRecordInput, ExamRecordPartUncheckedCreateWithoutExamRecordInput> | ExamRecordPartCreateWithoutExamRecordInput[] | ExamRecordPartUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordPartCreateOrConnectWithoutExamRecordInput | ExamRecordPartCreateOrConnectWithoutExamRecordInput[]
    createMany?: ExamRecordPartCreateManyExamRecordInputEnvelope
    connect?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
  }

  export type ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput = {
    create?: XOR<ExamRecordCareerCreateWithoutExamRecordInput, ExamRecordCareerUncheckedCreateWithoutExamRecordInput> | ExamRecordCareerCreateWithoutExamRecordInput[] | ExamRecordCareerUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutExamRecordInput | ExamRecordCareerCreateOrConnectWithoutExamRecordInput[]
    createMany?: ExamRecordCareerCreateManyExamRecordInputEnvelope
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
  }

  export type ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput = {
    create?: XOR<ExamRecordAreaCreateWithoutExamRecordInput, ExamRecordAreaUncheckedCreateWithoutExamRecordInput> | ExamRecordAreaCreateWithoutExamRecordInput[] | ExamRecordAreaUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutExamRecordInput | ExamRecordAreaCreateOrConnectWithoutExamRecordInput[]
    createMany?: ExamRecordAreaCreateManyExamRecordInputEnvelope
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
  }

  export type ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput = {
    create?: XOR<ExamRecordPartCreateWithoutExamRecordInput, ExamRecordPartUncheckedCreateWithoutExamRecordInput> | ExamRecordPartCreateWithoutExamRecordInput[] | ExamRecordPartUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordPartCreateOrConnectWithoutExamRecordInput | ExamRecordPartCreateOrConnectWithoutExamRecordInput[]
    createMany?: ExamRecordPartCreateManyExamRecordInputEnvelope
    connect?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput = {
    create?: XOR<OrganizationCreateWithoutExamRecordsInput, OrganizationUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutExamRecordsInput
    upsert?: OrganizationUpsertWithoutExamRecordsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutExamRecordsInput, OrganizationUpdateWithoutExamRecordsInput>, OrganizationUncheckedUpdateWithoutExamRecordsInput>
  }

  export type BoardUpdateOneRequiredWithoutExamRecordsNestedInput = {
    create?: XOR<BoardCreateWithoutExamRecordsInput, BoardUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutExamRecordsInput
    upsert?: BoardUpsertWithoutExamRecordsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutExamRecordsInput, BoardUpdateWithoutExamRecordsInput>, BoardUncheckedUpdateWithoutExamRecordsInput>
  }

  export type PositionUpdateOneRequiredWithoutExamRecordsNestedInput = {
    create?: XOR<PositionCreateWithoutExamRecordsInput, PositionUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: PositionCreateOrConnectWithoutExamRecordsInput
    upsert?: PositionUpsertWithoutExamRecordsInput
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutExamRecordsInput, PositionUpdateWithoutExamRecordsInput>, PositionUncheckedUpdateWithoutExamRecordsInput>
  }

  export type NoticeUpdateOneWithoutExamRecordsNestedInput = {
    create?: XOR<NoticeCreateWithoutExamRecordsInput, NoticeUncheckedCreateWithoutExamRecordsInput>
    connectOrCreate?: NoticeCreateOrConnectWithoutExamRecordsInput
    upsert?: NoticeUpsertWithoutExamRecordsInput
    disconnect?: NoticeWhereInput | boolean
    delete?: NoticeWhereInput | boolean
    connect?: NoticeWhereUniqueInput
    update?: XOR<XOR<NoticeUpdateToOneWithWhereWithoutExamRecordsInput, NoticeUpdateWithoutExamRecordsInput>, NoticeUncheckedUpdateWithoutExamRecordsInput>
  }

  export type ExamRecordCareerUpdateManyWithoutExamRecordNestedInput = {
    create?: XOR<ExamRecordCareerCreateWithoutExamRecordInput, ExamRecordCareerUncheckedCreateWithoutExamRecordInput> | ExamRecordCareerCreateWithoutExamRecordInput[] | ExamRecordCareerUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutExamRecordInput | ExamRecordCareerCreateOrConnectWithoutExamRecordInput[]
    upsert?: ExamRecordCareerUpsertWithWhereUniqueWithoutExamRecordInput | ExamRecordCareerUpsertWithWhereUniqueWithoutExamRecordInput[]
    createMany?: ExamRecordCareerCreateManyExamRecordInputEnvelope
    set?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    disconnect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    delete?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    update?: ExamRecordCareerUpdateWithWhereUniqueWithoutExamRecordInput | ExamRecordCareerUpdateWithWhereUniqueWithoutExamRecordInput[]
    updateMany?: ExamRecordCareerUpdateManyWithWhereWithoutExamRecordInput | ExamRecordCareerUpdateManyWithWhereWithoutExamRecordInput[]
    deleteMany?: ExamRecordCareerScalarWhereInput | ExamRecordCareerScalarWhereInput[]
  }

  export type ExamRecordAreaUpdateManyWithoutExamRecordNestedInput = {
    create?: XOR<ExamRecordAreaCreateWithoutExamRecordInput, ExamRecordAreaUncheckedCreateWithoutExamRecordInput> | ExamRecordAreaCreateWithoutExamRecordInput[] | ExamRecordAreaUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutExamRecordInput | ExamRecordAreaCreateOrConnectWithoutExamRecordInput[]
    upsert?: ExamRecordAreaUpsertWithWhereUniqueWithoutExamRecordInput | ExamRecordAreaUpsertWithWhereUniqueWithoutExamRecordInput[]
    createMany?: ExamRecordAreaCreateManyExamRecordInputEnvelope
    set?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    disconnect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    delete?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    update?: ExamRecordAreaUpdateWithWhereUniqueWithoutExamRecordInput | ExamRecordAreaUpdateWithWhereUniqueWithoutExamRecordInput[]
    updateMany?: ExamRecordAreaUpdateManyWithWhereWithoutExamRecordInput | ExamRecordAreaUpdateManyWithWhereWithoutExamRecordInput[]
    deleteMany?: ExamRecordAreaScalarWhereInput | ExamRecordAreaScalarWhereInput[]
  }

  export type ExamRecordPartUpdateManyWithoutExamRecordNestedInput = {
    create?: XOR<ExamRecordPartCreateWithoutExamRecordInput, ExamRecordPartUncheckedCreateWithoutExamRecordInput> | ExamRecordPartCreateWithoutExamRecordInput[] | ExamRecordPartUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordPartCreateOrConnectWithoutExamRecordInput | ExamRecordPartCreateOrConnectWithoutExamRecordInput[]
    upsert?: ExamRecordPartUpsertWithWhereUniqueWithoutExamRecordInput | ExamRecordPartUpsertWithWhereUniqueWithoutExamRecordInput[]
    createMany?: ExamRecordPartCreateManyExamRecordInputEnvelope
    set?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    disconnect?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    delete?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    connect?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    update?: ExamRecordPartUpdateWithWhereUniqueWithoutExamRecordInput | ExamRecordPartUpdateWithWhereUniqueWithoutExamRecordInput[]
    updateMany?: ExamRecordPartUpdateManyWithWhereWithoutExamRecordInput | ExamRecordPartUpdateManyWithWhereWithoutExamRecordInput[]
    deleteMany?: ExamRecordPartScalarWhereInput | ExamRecordPartScalarWhereInput[]
  }

  export type ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput = {
    create?: XOR<ExamRecordCareerCreateWithoutExamRecordInput, ExamRecordCareerUncheckedCreateWithoutExamRecordInput> | ExamRecordCareerCreateWithoutExamRecordInput[] | ExamRecordCareerUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordCareerCreateOrConnectWithoutExamRecordInput | ExamRecordCareerCreateOrConnectWithoutExamRecordInput[]
    upsert?: ExamRecordCareerUpsertWithWhereUniqueWithoutExamRecordInput | ExamRecordCareerUpsertWithWhereUniqueWithoutExamRecordInput[]
    createMany?: ExamRecordCareerCreateManyExamRecordInputEnvelope
    set?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    disconnect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    delete?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    connect?: ExamRecordCareerWhereUniqueInput | ExamRecordCareerWhereUniqueInput[]
    update?: ExamRecordCareerUpdateWithWhereUniqueWithoutExamRecordInput | ExamRecordCareerUpdateWithWhereUniqueWithoutExamRecordInput[]
    updateMany?: ExamRecordCareerUpdateManyWithWhereWithoutExamRecordInput | ExamRecordCareerUpdateManyWithWhereWithoutExamRecordInput[]
    deleteMany?: ExamRecordCareerScalarWhereInput | ExamRecordCareerScalarWhereInput[]
  }

  export type ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput = {
    create?: XOR<ExamRecordAreaCreateWithoutExamRecordInput, ExamRecordAreaUncheckedCreateWithoutExamRecordInput> | ExamRecordAreaCreateWithoutExamRecordInput[] | ExamRecordAreaUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordAreaCreateOrConnectWithoutExamRecordInput | ExamRecordAreaCreateOrConnectWithoutExamRecordInput[]
    upsert?: ExamRecordAreaUpsertWithWhereUniqueWithoutExamRecordInput | ExamRecordAreaUpsertWithWhereUniqueWithoutExamRecordInput[]
    createMany?: ExamRecordAreaCreateManyExamRecordInputEnvelope
    set?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    disconnect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    delete?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    connect?: ExamRecordAreaWhereUniqueInput | ExamRecordAreaWhereUniqueInput[]
    update?: ExamRecordAreaUpdateWithWhereUniqueWithoutExamRecordInput | ExamRecordAreaUpdateWithWhereUniqueWithoutExamRecordInput[]
    updateMany?: ExamRecordAreaUpdateManyWithWhereWithoutExamRecordInput | ExamRecordAreaUpdateManyWithWhereWithoutExamRecordInput[]
    deleteMany?: ExamRecordAreaScalarWhereInput | ExamRecordAreaScalarWhereInput[]
  }

  export type ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput = {
    create?: XOR<ExamRecordPartCreateWithoutExamRecordInput, ExamRecordPartUncheckedCreateWithoutExamRecordInput> | ExamRecordPartCreateWithoutExamRecordInput[] | ExamRecordPartUncheckedCreateWithoutExamRecordInput[]
    connectOrCreate?: ExamRecordPartCreateOrConnectWithoutExamRecordInput | ExamRecordPartCreateOrConnectWithoutExamRecordInput[]
    upsert?: ExamRecordPartUpsertWithWhereUniqueWithoutExamRecordInput | ExamRecordPartUpsertWithWhereUniqueWithoutExamRecordInput[]
    createMany?: ExamRecordPartCreateManyExamRecordInputEnvelope
    set?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    disconnect?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    delete?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    connect?: ExamRecordPartWhereUniqueInput | ExamRecordPartWhereUniqueInput[]
    update?: ExamRecordPartUpdateWithWhereUniqueWithoutExamRecordInput | ExamRecordPartUpdateWithWhereUniqueWithoutExamRecordInput[]
    updateMany?: ExamRecordPartUpdateManyWithWhereWithoutExamRecordInput | ExamRecordPartUpdateManyWithWhereWithoutExamRecordInput[]
    deleteMany?: ExamRecordPartScalarWhereInput | ExamRecordPartScalarWhereInput[]
  }

  export type ExamRecordCreateNestedOneWithoutCareersInput = {
    create?: XOR<ExamRecordCreateWithoutCareersInput, ExamRecordUncheckedCreateWithoutCareersInput>
    connectOrCreate?: ExamRecordCreateOrConnectWithoutCareersInput
    connect?: ExamRecordWhereUniqueInput
  }

  export type CareerCreateNestedOneWithoutExamsInput = {
    create?: XOR<CareerCreateWithoutExamsInput, CareerUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutExamsInput
    connect?: CareerWhereUniqueInput
  }

  export type ExamRecordUpdateOneRequiredWithoutCareersNestedInput = {
    create?: XOR<ExamRecordCreateWithoutCareersInput, ExamRecordUncheckedCreateWithoutCareersInput>
    connectOrCreate?: ExamRecordCreateOrConnectWithoutCareersInput
    upsert?: ExamRecordUpsertWithoutCareersInput
    connect?: ExamRecordWhereUniqueInput
    update?: XOR<XOR<ExamRecordUpdateToOneWithWhereWithoutCareersInput, ExamRecordUpdateWithoutCareersInput>, ExamRecordUncheckedUpdateWithoutCareersInput>
  }

  export type CareerUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<CareerCreateWithoutExamsInput, CareerUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CareerCreateOrConnectWithoutExamsInput
    upsert?: CareerUpsertWithoutExamsInput
    connect?: CareerWhereUniqueInput
    update?: XOR<XOR<CareerUpdateToOneWithWhereWithoutExamsInput, CareerUpdateWithoutExamsInput>, CareerUncheckedUpdateWithoutExamsInput>
  }

  export type ExamRecordCreateNestedOneWithoutAreasInput = {
    create?: XOR<ExamRecordCreateWithoutAreasInput, ExamRecordUncheckedCreateWithoutAreasInput>
    connectOrCreate?: ExamRecordCreateOrConnectWithoutAreasInput
    connect?: ExamRecordWhereUniqueInput
  }

  export type AreaCreateNestedOneWithoutExamsInput = {
    create?: XOR<AreaCreateWithoutExamsInput, AreaUncheckedCreateWithoutExamsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutExamsInput
    connect?: AreaWhereUniqueInput
  }

  export type ExamRecordUpdateOneRequiredWithoutAreasNestedInput = {
    create?: XOR<ExamRecordCreateWithoutAreasInput, ExamRecordUncheckedCreateWithoutAreasInput>
    connectOrCreate?: ExamRecordCreateOrConnectWithoutAreasInput
    upsert?: ExamRecordUpsertWithoutAreasInput
    connect?: ExamRecordWhereUniqueInput
    update?: XOR<XOR<ExamRecordUpdateToOneWithWhereWithoutAreasInput, ExamRecordUpdateWithoutAreasInput>, ExamRecordUncheckedUpdateWithoutAreasInput>
  }

  export type AreaUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<AreaCreateWithoutExamsInput, AreaUncheckedCreateWithoutExamsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutExamsInput
    upsert?: AreaUpsertWithoutExamsInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutExamsInput, AreaUpdateWithoutExamsInput>, AreaUncheckedUpdateWithoutExamsInput>
  }

  export type ExamRecordCreateNestedOneWithoutPartsInput = {
    create?: XOR<ExamRecordCreateWithoutPartsInput, ExamRecordUncheckedCreateWithoutPartsInput>
    connectOrCreate?: ExamRecordCreateOrConnectWithoutPartsInput
    connect?: ExamRecordWhereUniqueInput
  }

  export type ExamRecordUpdateOneRequiredWithoutPartsNestedInput = {
    create?: XOR<ExamRecordCreateWithoutPartsInput, ExamRecordUncheckedCreateWithoutPartsInput>
    connectOrCreate?: ExamRecordCreateOrConnectWithoutPartsInput
    upsert?: ExamRecordUpsertWithoutPartsInput
    connect?: ExamRecordWhereUniqueInput
    update?: XOR<XOR<ExamRecordUpdateToOneWithWhereWithoutPartsInput, ExamRecordUpdateWithoutPartsInput>, ExamRecordUncheckedUpdateWithoutPartsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type QuestionCreateWithoutExamInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutExamInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutExamInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput>
  }

  export type QuestionCreateManyExamInputEnvelope = {
    data: QuestionCreateManyExamInput | QuestionCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithWhereUniqueWithoutExamInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutExamInput, QuestionUncheckedUpdateWithoutExamInput>
    create: XOR<QuestionCreateWithoutExamInput, QuestionUncheckedCreateWithoutExamInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutExamInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutExamInput, QuestionUncheckedUpdateWithoutExamInput>
  }

  export type QuestionUpdateManyWithWhereWithoutExamInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutExamInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    statement?: StringFilter<"Question"> | string
    organization?: StringFilter<"Question"> | string
    subject?: StringFilter<"Question"> | string
    examId?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
  }

  export type ExamCreateWithoutQuestionsInput = {
    id?: string
    title: string
    year: number
    organization: string
    institution: string
    level: string
    sourceUrl?: string | null
    examPdfUrl?: string | null
    answerKeyUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    year: number
    organization: string
    institution: string
    level: string
    sourceUrl?: string | null
    examPdfUrl?: string | null
    answerKeyUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateOrConnectWithoutQuestionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
  }

  export type AlternativeCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeUncheckedCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeCreateOrConnectWithoutQuestionInput = {
    where: AlternativeWhereUniqueInput
    create: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput>
  }

  export type AlternativeCreateManyQuestionInputEnvelope = {
    data: AlternativeCreateManyQuestionInput | AlternativeCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ExamUpsertWithoutQuestionsInput = {
    update: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    organization?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    examPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    organization?: StringFieldUpdateOperationsInput | string
    institution?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    examPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AlternativeWhereUniqueInput
    update: XOR<AlternativeUpdateWithoutQuestionInput, AlternativeUncheckedUpdateWithoutQuestionInput>
    create: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput>
  }

  export type AlternativeUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AlternativeWhereUniqueInput
    data: XOR<AlternativeUpdateWithoutQuestionInput, AlternativeUncheckedUpdateWithoutQuestionInput>
  }

  export type AlternativeUpdateManyWithWhereWithoutQuestionInput = {
    where: AlternativeScalarWhereInput
    data: XOR<AlternativeUpdateManyMutationInput, AlternativeUncheckedUpdateManyWithoutQuestionInput>
  }

  export type AlternativeScalarWhereInput = {
    AND?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
    OR?: AlternativeScalarWhereInput[]
    NOT?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
    id?: StringFilter<"Alternative"> | string
    text?: StringFilter<"Alternative"> | string
    isCorrect?: BoolFilter<"Alternative"> | boolean
    questionId?: StringFilter<"Alternative"> | string
    createdAt?: DateTimeFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeFilter<"Alternative"> | Date | string
  }

  export type QuestionCreateWithoutAlternativesInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exam?: ExamCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateWithoutAlternativesInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    examId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateOrConnectWithoutAlternativesInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
  }

  export type QuestionUpsertWithoutAlternativesInput = {
    update: XOR<QuestionUpdateWithoutAlternativesInput, QuestionUncheckedUpdateWithoutAlternativesInput>
    create: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutAlternativesInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutAlternativesInput, QuestionUncheckedUpdateWithoutAlternativesInput>
  }

  export type QuestionUpdateWithoutAlternativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAlternativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    examId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationAnswerCreateWithoutSimulationInput = {
    id?: string
    questionId: string
    alternativeId: string
    createdAt?: Date | string
  }

  export type SimulationAnswerUncheckedCreateWithoutSimulationInput = {
    id?: string
    questionId: string
    alternativeId: string
    createdAt?: Date | string
  }

  export type SimulationAnswerCreateOrConnectWithoutSimulationInput = {
    where: SimulationAnswerWhereUniqueInput
    create: XOR<SimulationAnswerCreateWithoutSimulationInput, SimulationAnswerUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationAnswerCreateManySimulationInputEnvelope = {
    data: SimulationAnswerCreateManySimulationInput | SimulationAnswerCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type SimulationAnswerUpsertWithWhereUniqueWithoutSimulationInput = {
    where: SimulationAnswerWhereUniqueInput
    update: XOR<SimulationAnswerUpdateWithoutSimulationInput, SimulationAnswerUncheckedUpdateWithoutSimulationInput>
    create: XOR<SimulationAnswerCreateWithoutSimulationInput, SimulationAnswerUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationAnswerUpdateWithWhereUniqueWithoutSimulationInput = {
    where: SimulationAnswerWhereUniqueInput
    data: XOR<SimulationAnswerUpdateWithoutSimulationInput, SimulationAnswerUncheckedUpdateWithoutSimulationInput>
  }

  export type SimulationAnswerUpdateManyWithWhereWithoutSimulationInput = {
    where: SimulationAnswerScalarWhereInput
    data: XOR<SimulationAnswerUpdateManyMutationInput, SimulationAnswerUncheckedUpdateManyWithoutSimulationInput>
  }

  export type SimulationAnswerScalarWhereInput = {
    AND?: SimulationAnswerScalarWhereInput | SimulationAnswerScalarWhereInput[]
    OR?: SimulationAnswerScalarWhereInput[]
    NOT?: SimulationAnswerScalarWhereInput | SimulationAnswerScalarWhereInput[]
    id?: StringFilter<"SimulationAnswer"> | string
    simulationId?: StringFilter<"SimulationAnswer"> | string
    questionId?: StringFilter<"SimulationAnswer"> | string
    alternativeId?: StringFilter<"SimulationAnswer"> | string
    createdAt?: DateTimeFilter<"SimulationAnswer"> | Date | string
  }

  export type SimulationCreateWithoutAnswersInput = {
    id?: string
    studentId: string
    title: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type SimulationUncheckedCreateWithoutAnswersInput = {
    id?: string
    studentId: string
    title: string
    createdAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type SimulationCreateOrConnectWithoutAnswersInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutAnswersInput, SimulationUncheckedCreateWithoutAnswersInput>
  }

  export type SimulationUpsertWithoutAnswersInput = {
    update: XOR<SimulationUpdateWithoutAnswersInput, SimulationUncheckedUpdateWithoutAnswersInput>
    create: XOR<SimulationCreateWithoutAnswersInput, SimulationUncheckedCreateWithoutAnswersInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutAnswersInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutAnswersInput, SimulationUncheckedUpdateWithoutAnswersInput>
  }

  export type SimulationUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimulationUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamRecordCreateWithoutOrganizationInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutExamRecordsInput
    position: PositionCreateNestedOneWithoutExamRecordsInput
    notice?: NoticeCreateNestedOneWithoutExamRecordsInput
    careers?: ExamRecordCareerCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateWithoutOrganizationInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    boardId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    careers?: ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordCreateOrConnectWithoutOrganizationInput = {
    where: ExamRecordWhereUniqueInput
    create: XOR<ExamRecordCreateWithoutOrganizationInput, ExamRecordUncheckedCreateWithoutOrganizationInput>
  }

  export type ExamRecordCreateManyOrganizationInputEnvelope = {
    data: ExamRecordCreateManyOrganizationInput | ExamRecordCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ExamRecordWhereUniqueInput
    update: XOR<ExamRecordUpdateWithoutOrganizationInput, ExamRecordUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ExamRecordCreateWithoutOrganizationInput, ExamRecordUncheckedCreateWithoutOrganizationInput>
  }

  export type ExamRecordUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ExamRecordWhereUniqueInput
    data: XOR<ExamRecordUpdateWithoutOrganizationInput, ExamRecordUncheckedUpdateWithoutOrganizationInput>
  }

  export type ExamRecordUpdateManyWithWhereWithoutOrganizationInput = {
    where: ExamRecordScalarWhereInput
    data: XOR<ExamRecordUpdateManyMutationInput, ExamRecordUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ExamRecordScalarWhereInput = {
    AND?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
    OR?: ExamRecordScalarWhereInput[]
    NOT?: ExamRecordScalarWhereInput | ExamRecordScalarWhereInput[]
    id?: StringFilter<"ExamRecord"> | string
    externalId?: IntFilter<"ExamRecord"> | number
    slug?: StringFilter<"ExamRecord"> | string
    name?: StringFilter<"ExamRecord"> | string
    type?: IntFilter<"ExamRecord"> | number
    year?: IntFilter<"ExamRecord"> | number
    level?: StringFilter<"ExamRecord"> | string
    questionCount?: IntFilter<"ExamRecord"> | number
    durationMinutes?: IntNullableFilter<"ExamRecord"> | number | null
    reviewed?: BoolFilter<"ExamRecord"> | boolean
    hasPendencies?: BoolFilter<"ExamRecord"> | boolean
    available?: BoolFilter<"ExamRecord"> | boolean
    observations?: StringNullableFilter<"ExamRecord"> | string | null
    otherData?: StringNullableFilter<"ExamRecord"> | string | null
    timestamp?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    publishedAt?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    applicationDate?: DateTimeNullableFilter<"ExamRecord"> | Date | string | null
    examFileKey?: StringNullableFilter<"ExamRecord"> | string | null
    answerKeyFileKey?: StringNullableFilter<"ExamRecord"> | string | null
    organizationId?: StringFilter<"ExamRecord"> | string
    boardId?: StringFilter<"ExamRecord"> | string
    positionId?: StringFilter<"ExamRecord"> | string
    noticeId?: StringNullableFilter<"ExamRecord"> | string | null
    createdAt?: DateTimeFilter<"ExamRecord"> | Date | string
    updatedAt?: DateTimeFilter<"ExamRecord"> | Date | string
  }

  export type ExamRecordCreateWithoutBoardInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutExamRecordsInput
    position: PositionCreateNestedOneWithoutExamRecordsInput
    notice?: NoticeCreateNestedOneWithoutExamRecordsInput
    careers?: ExamRecordCareerCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateWithoutBoardInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    careers?: ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordCreateOrConnectWithoutBoardInput = {
    where: ExamRecordWhereUniqueInput
    create: XOR<ExamRecordCreateWithoutBoardInput, ExamRecordUncheckedCreateWithoutBoardInput>
  }

  export type ExamRecordCreateManyBoardInputEnvelope = {
    data: ExamRecordCreateManyBoardInput | ExamRecordCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordUpsertWithWhereUniqueWithoutBoardInput = {
    where: ExamRecordWhereUniqueInput
    update: XOR<ExamRecordUpdateWithoutBoardInput, ExamRecordUncheckedUpdateWithoutBoardInput>
    create: XOR<ExamRecordCreateWithoutBoardInput, ExamRecordUncheckedCreateWithoutBoardInput>
  }

  export type ExamRecordUpdateWithWhereUniqueWithoutBoardInput = {
    where: ExamRecordWhereUniqueInput
    data: XOR<ExamRecordUpdateWithoutBoardInput, ExamRecordUncheckedUpdateWithoutBoardInput>
  }

  export type ExamRecordUpdateManyWithWhereWithoutBoardInput = {
    where: ExamRecordScalarWhereInput
    data: XOR<ExamRecordUpdateManyMutationInput, ExamRecordUncheckedUpdateManyWithoutBoardInput>
  }

  export type ExamRecordCreateWithoutPositionInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutExamRecordsInput
    board: BoardCreateNestedOneWithoutExamRecordsInput
    notice?: NoticeCreateNestedOneWithoutExamRecordsInput
    careers?: ExamRecordCareerCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateWithoutPositionInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    careers?: ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordCreateOrConnectWithoutPositionInput = {
    where: ExamRecordWhereUniqueInput
    create: XOR<ExamRecordCreateWithoutPositionInput, ExamRecordUncheckedCreateWithoutPositionInput>
  }

  export type ExamRecordCreateManyPositionInputEnvelope = {
    data: ExamRecordCreateManyPositionInput | ExamRecordCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordUpsertWithWhereUniqueWithoutPositionInput = {
    where: ExamRecordWhereUniqueInput
    update: XOR<ExamRecordUpdateWithoutPositionInput, ExamRecordUncheckedUpdateWithoutPositionInput>
    create: XOR<ExamRecordCreateWithoutPositionInput, ExamRecordUncheckedCreateWithoutPositionInput>
  }

  export type ExamRecordUpdateWithWhereUniqueWithoutPositionInput = {
    where: ExamRecordWhereUniqueInput
    data: XOR<ExamRecordUpdateWithoutPositionInput, ExamRecordUncheckedUpdateWithoutPositionInput>
  }

  export type ExamRecordUpdateManyWithWhereWithoutPositionInput = {
    where: ExamRecordScalarWhereInput
    data: XOR<ExamRecordUpdateManyMutationInput, ExamRecordUncheckedUpdateManyWithoutPositionInput>
  }

  export type ExamRecordCreateWithoutNoticeInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutExamRecordsInput
    board: BoardCreateNestedOneWithoutExamRecordsInput
    position: PositionCreateNestedOneWithoutExamRecordsInput
    careers?: ExamRecordCareerCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateWithoutNoticeInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    positionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    careers?: ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordCreateOrConnectWithoutNoticeInput = {
    where: ExamRecordWhereUniqueInput
    create: XOR<ExamRecordCreateWithoutNoticeInput, ExamRecordUncheckedCreateWithoutNoticeInput>
  }

  export type ExamRecordCreateManyNoticeInputEnvelope = {
    data: ExamRecordCreateManyNoticeInput | ExamRecordCreateManyNoticeInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordUpsertWithWhereUniqueWithoutNoticeInput = {
    where: ExamRecordWhereUniqueInput
    update: XOR<ExamRecordUpdateWithoutNoticeInput, ExamRecordUncheckedUpdateWithoutNoticeInput>
    create: XOR<ExamRecordCreateWithoutNoticeInput, ExamRecordUncheckedCreateWithoutNoticeInput>
  }

  export type ExamRecordUpdateWithWhereUniqueWithoutNoticeInput = {
    where: ExamRecordWhereUniqueInput
    data: XOR<ExamRecordUpdateWithoutNoticeInput, ExamRecordUncheckedUpdateWithoutNoticeInput>
  }

  export type ExamRecordUpdateManyWithWhereWithoutNoticeInput = {
    where: ExamRecordScalarWhereInput
    data: XOR<ExamRecordUpdateManyMutationInput, ExamRecordUncheckedUpdateManyWithoutNoticeInput>
  }

  export type ExamRecordCareerCreateWithoutCareerInput = {
    id?: string
    examRecord: ExamRecordCreateNestedOneWithoutCareersInput
  }

  export type ExamRecordCareerUncheckedCreateWithoutCareerInput = {
    id?: string
    examRecordId: string
  }

  export type ExamRecordCareerCreateOrConnectWithoutCareerInput = {
    where: ExamRecordCareerWhereUniqueInput
    create: XOR<ExamRecordCareerCreateWithoutCareerInput, ExamRecordCareerUncheckedCreateWithoutCareerInput>
  }

  export type ExamRecordCareerCreateManyCareerInputEnvelope = {
    data: ExamRecordCareerCreateManyCareerInput | ExamRecordCareerCreateManyCareerInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordCareerUpsertWithWhereUniqueWithoutCareerInput = {
    where: ExamRecordCareerWhereUniqueInput
    update: XOR<ExamRecordCareerUpdateWithoutCareerInput, ExamRecordCareerUncheckedUpdateWithoutCareerInput>
    create: XOR<ExamRecordCareerCreateWithoutCareerInput, ExamRecordCareerUncheckedCreateWithoutCareerInput>
  }

  export type ExamRecordCareerUpdateWithWhereUniqueWithoutCareerInput = {
    where: ExamRecordCareerWhereUniqueInput
    data: XOR<ExamRecordCareerUpdateWithoutCareerInput, ExamRecordCareerUncheckedUpdateWithoutCareerInput>
  }

  export type ExamRecordCareerUpdateManyWithWhereWithoutCareerInput = {
    where: ExamRecordCareerScalarWhereInput
    data: XOR<ExamRecordCareerUpdateManyMutationInput, ExamRecordCareerUncheckedUpdateManyWithoutCareerInput>
  }

  export type ExamRecordCareerScalarWhereInput = {
    AND?: ExamRecordCareerScalarWhereInput | ExamRecordCareerScalarWhereInput[]
    OR?: ExamRecordCareerScalarWhereInput[]
    NOT?: ExamRecordCareerScalarWhereInput | ExamRecordCareerScalarWhereInput[]
    id?: StringFilter<"ExamRecordCareer"> | string
    examRecordId?: StringFilter<"ExamRecordCareer"> | string
    careerId?: StringFilter<"ExamRecordCareer"> | string
  }

  export type ExamRecordAreaCreateWithoutAreaInput = {
    id?: string
    examRecord: ExamRecordCreateNestedOneWithoutAreasInput
  }

  export type ExamRecordAreaUncheckedCreateWithoutAreaInput = {
    id?: string
    examRecordId: string
  }

  export type ExamRecordAreaCreateOrConnectWithoutAreaInput = {
    where: ExamRecordAreaWhereUniqueInput
    create: XOR<ExamRecordAreaCreateWithoutAreaInput, ExamRecordAreaUncheckedCreateWithoutAreaInput>
  }

  export type ExamRecordAreaCreateManyAreaInputEnvelope = {
    data: ExamRecordAreaCreateManyAreaInput | ExamRecordAreaCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordAreaUpsertWithWhereUniqueWithoutAreaInput = {
    where: ExamRecordAreaWhereUniqueInput
    update: XOR<ExamRecordAreaUpdateWithoutAreaInput, ExamRecordAreaUncheckedUpdateWithoutAreaInput>
    create: XOR<ExamRecordAreaCreateWithoutAreaInput, ExamRecordAreaUncheckedCreateWithoutAreaInput>
  }

  export type ExamRecordAreaUpdateWithWhereUniqueWithoutAreaInput = {
    where: ExamRecordAreaWhereUniqueInput
    data: XOR<ExamRecordAreaUpdateWithoutAreaInput, ExamRecordAreaUncheckedUpdateWithoutAreaInput>
  }

  export type ExamRecordAreaUpdateManyWithWhereWithoutAreaInput = {
    where: ExamRecordAreaScalarWhereInput
    data: XOR<ExamRecordAreaUpdateManyMutationInput, ExamRecordAreaUncheckedUpdateManyWithoutAreaInput>
  }

  export type ExamRecordAreaScalarWhereInput = {
    AND?: ExamRecordAreaScalarWhereInput | ExamRecordAreaScalarWhereInput[]
    OR?: ExamRecordAreaScalarWhereInput[]
    NOT?: ExamRecordAreaScalarWhereInput | ExamRecordAreaScalarWhereInput[]
    id?: StringFilter<"ExamRecordArea"> | string
    examRecordId?: StringFilter<"ExamRecordArea"> | string
    areaId?: StringFilter<"ExamRecordArea"> | string
  }

  export type OrganizationCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    name: string
    acronym?: string | null
    sphere?: string | null
    state?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    name: string
    acronym?: string | null
    sphere?: string | null
    state?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutExamRecordsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutExamRecordsInput, OrganizationUncheckedCreateWithoutExamRecordsInput>
  }

  export type BoardCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    acronym?: string | null
    isOab?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardUncheckedCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    acronym?: string | null
    isOab?: boolean
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardCreateOrConnectWithoutExamRecordsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutExamRecordsInput, BoardUncheckedCreateWithoutExamRecordsInput>
  }

  export type PositionCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUncheckedCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateOrConnectWithoutExamRecordsInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutExamRecordsInput, PositionUncheckedCreateWithoutExamRecordsInput>
  }

  export type NoticeCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    slug?: string | null
    enrollmentStart?: Date | string | null
    enrollmentEnd?: Date | string | null
    plannedApplication?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeUncheckedCreateWithoutExamRecordsInput = {
    id?: string
    externalId: number
    slug?: string | null
    enrollmentStart?: Date | string | null
    enrollmentEnd?: Date | string | null
    plannedApplication?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeCreateOrConnectWithoutExamRecordsInput = {
    where: NoticeWhereUniqueInput
    create: XOR<NoticeCreateWithoutExamRecordsInput, NoticeUncheckedCreateWithoutExamRecordsInput>
  }

  export type ExamRecordCareerCreateWithoutExamRecordInput = {
    id?: string
    career: CareerCreateNestedOneWithoutExamsInput
  }

  export type ExamRecordCareerUncheckedCreateWithoutExamRecordInput = {
    id?: string
    careerId: string
  }

  export type ExamRecordCareerCreateOrConnectWithoutExamRecordInput = {
    where: ExamRecordCareerWhereUniqueInput
    create: XOR<ExamRecordCareerCreateWithoutExamRecordInput, ExamRecordCareerUncheckedCreateWithoutExamRecordInput>
  }

  export type ExamRecordCareerCreateManyExamRecordInputEnvelope = {
    data: ExamRecordCareerCreateManyExamRecordInput | ExamRecordCareerCreateManyExamRecordInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordAreaCreateWithoutExamRecordInput = {
    id?: string
    area: AreaCreateNestedOneWithoutExamsInput
  }

  export type ExamRecordAreaUncheckedCreateWithoutExamRecordInput = {
    id?: string
    areaId: string
  }

  export type ExamRecordAreaCreateOrConnectWithoutExamRecordInput = {
    where: ExamRecordAreaWhereUniqueInput
    create: XOR<ExamRecordAreaCreateWithoutExamRecordInput, ExamRecordAreaUncheckedCreateWithoutExamRecordInput>
  }

  export type ExamRecordAreaCreateManyExamRecordInputEnvelope = {
    data: ExamRecordAreaCreateManyExamRecordInput | ExamRecordAreaCreateManyExamRecordInput[]
    skipDuplicates?: boolean
  }

  export type ExamRecordPartCreateWithoutExamRecordInput = {
    id?: string
    externalId?: number | null
    description: string
  }

  export type ExamRecordPartUncheckedCreateWithoutExamRecordInput = {
    id?: string
    externalId?: number | null
    description: string
  }

  export type ExamRecordPartCreateOrConnectWithoutExamRecordInput = {
    where: ExamRecordPartWhereUniqueInput
    create: XOR<ExamRecordPartCreateWithoutExamRecordInput, ExamRecordPartUncheckedCreateWithoutExamRecordInput>
  }

  export type ExamRecordPartCreateManyExamRecordInputEnvelope = {
    data: ExamRecordPartCreateManyExamRecordInput | ExamRecordPartCreateManyExamRecordInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutExamRecordsInput = {
    update: XOR<OrganizationUpdateWithoutExamRecordsInput, OrganizationUncheckedUpdateWithoutExamRecordsInput>
    create: XOR<OrganizationCreateWithoutExamRecordsInput, OrganizationUncheckedCreateWithoutExamRecordsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutExamRecordsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutExamRecordsInput, OrganizationUncheckedUpdateWithoutExamRecordsInput>
  }

  export type OrganizationUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    sphere?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    sphere?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUpsertWithoutExamRecordsInput = {
    update: XOR<BoardUpdateWithoutExamRecordsInput, BoardUncheckedUpdateWithoutExamRecordsInput>
    create: XOR<BoardCreateWithoutExamRecordsInput, BoardUncheckedCreateWithoutExamRecordsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutExamRecordsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutExamRecordsInput, BoardUncheckedUpdateWithoutExamRecordsInput>
  }

  export type BoardUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    isOab?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUncheckedUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    isOab?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUpsertWithoutExamRecordsInput = {
    update: XOR<PositionUpdateWithoutExamRecordsInput, PositionUncheckedUpdateWithoutExamRecordsInput>
    create: XOR<PositionCreateWithoutExamRecordsInput, PositionUncheckedCreateWithoutExamRecordsInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutExamRecordsInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutExamRecordsInput, PositionUncheckedUpdateWithoutExamRecordsInput>
  }

  export type PositionUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUpsertWithoutExamRecordsInput = {
    update: XOR<NoticeUpdateWithoutExamRecordsInput, NoticeUncheckedUpdateWithoutExamRecordsInput>
    create: XOR<NoticeCreateWithoutExamRecordsInput, NoticeUncheckedCreateWithoutExamRecordsInput>
    where?: NoticeWhereInput
  }

  export type NoticeUpdateToOneWithWhereWithoutExamRecordsInput = {
    where?: NoticeWhereInput
    data: XOR<NoticeUpdateWithoutExamRecordsInput, NoticeUncheckedUpdateWithoutExamRecordsInput>
  }

  export type NoticeUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedApplication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateWithoutExamRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollmentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedApplication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCareerUpsertWithWhereUniqueWithoutExamRecordInput = {
    where: ExamRecordCareerWhereUniqueInput
    update: XOR<ExamRecordCareerUpdateWithoutExamRecordInput, ExamRecordCareerUncheckedUpdateWithoutExamRecordInput>
    create: XOR<ExamRecordCareerCreateWithoutExamRecordInput, ExamRecordCareerUncheckedCreateWithoutExamRecordInput>
  }

  export type ExamRecordCareerUpdateWithWhereUniqueWithoutExamRecordInput = {
    where: ExamRecordCareerWhereUniqueInput
    data: XOR<ExamRecordCareerUpdateWithoutExamRecordInput, ExamRecordCareerUncheckedUpdateWithoutExamRecordInput>
  }

  export type ExamRecordCareerUpdateManyWithWhereWithoutExamRecordInput = {
    where: ExamRecordCareerScalarWhereInput
    data: XOR<ExamRecordCareerUpdateManyMutationInput, ExamRecordCareerUncheckedUpdateManyWithoutExamRecordInput>
  }

  export type ExamRecordAreaUpsertWithWhereUniqueWithoutExamRecordInput = {
    where: ExamRecordAreaWhereUniqueInput
    update: XOR<ExamRecordAreaUpdateWithoutExamRecordInput, ExamRecordAreaUncheckedUpdateWithoutExamRecordInput>
    create: XOR<ExamRecordAreaCreateWithoutExamRecordInput, ExamRecordAreaUncheckedCreateWithoutExamRecordInput>
  }

  export type ExamRecordAreaUpdateWithWhereUniqueWithoutExamRecordInput = {
    where: ExamRecordAreaWhereUniqueInput
    data: XOR<ExamRecordAreaUpdateWithoutExamRecordInput, ExamRecordAreaUncheckedUpdateWithoutExamRecordInput>
  }

  export type ExamRecordAreaUpdateManyWithWhereWithoutExamRecordInput = {
    where: ExamRecordAreaScalarWhereInput
    data: XOR<ExamRecordAreaUpdateManyMutationInput, ExamRecordAreaUncheckedUpdateManyWithoutExamRecordInput>
  }

  export type ExamRecordPartUpsertWithWhereUniqueWithoutExamRecordInput = {
    where: ExamRecordPartWhereUniqueInput
    update: XOR<ExamRecordPartUpdateWithoutExamRecordInput, ExamRecordPartUncheckedUpdateWithoutExamRecordInput>
    create: XOR<ExamRecordPartCreateWithoutExamRecordInput, ExamRecordPartUncheckedCreateWithoutExamRecordInput>
  }

  export type ExamRecordPartUpdateWithWhereUniqueWithoutExamRecordInput = {
    where: ExamRecordPartWhereUniqueInput
    data: XOR<ExamRecordPartUpdateWithoutExamRecordInput, ExamRecordPartUncheckedUpdateWithoutExamRecordInput>
  }

  export type ExamRecordPartUpdateManyWithWhereWithoutExamRecordInput = {
    where: ExamRecordPartScalarWhereInput
    data: XOR<ExamRecordPartUpdateManyMutationInput, ExamRecordPartUncheckedUpdateManyWithoutExamRecordInput>
  }

  export type ExamRecordPartScalarWhereInput = {
    AND?: ExamRecordPartScalarWhereInput | ExamRecordPartScalarWhereInput[]
    OR?: ExamRecordPartScalarWhereInput[]
    NOT?: ExamRecordPartScalarWhereInput | ExamRecordPartScalarWhereInput[]
    id?: StringFilter<"ExamRecordPart"> | string
    examRecordId?: StringFilter<"ExamRecordPart"> | string
    externalId?: IntNullableFilter<"ExamRecordPart"> | number | null
    description?: StringFilter<"ExamRecordPart"> | string
  }

  export type ExamRecordCreateWithoutCareersInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutExamRecordsInput
    board: BoardCreateNestedOneWithoutExamRecordsInput
    position: PositionCreateNestedOneWithoutExamRecordsInput
    notice?: NoticeCreateNestedOneWithoutExamRecordsInput
    areas?: ExamRecordAreaCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateWithoutCareersInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    areas?: ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordCreateOrConnectWithoutCareersInput = {
    where: ExamRecordWhereUniqueInput
    create: XOR<ExamRecordCreateWithoutCareersInput, ExamRecordUncheckedCreateWithoutCareersInput>
  }

  export type CareerCreateWithoutExamsInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerUncheckedCreateWithoutExamsInput = {
    id?: string
    externalId: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CareerCreateOrConnectWithoutExamsInput = {
    where: CareerWhereUniqueInput
    create: XOR<CareerCreateWithoutExamsInput, CareerUncheckedCreateWithoutExamsInput>
  }

  export type ExamRecordUpsertWithoutCareersInput = {
    update: XOR<ExamRecordUpdateWithoutCareersInput, ExamRecordUncheckedUpdateWithoutCareersInput>
    create: XOR<ExamRecordCreateWithoutCareersInput, ExamRecordUncheckedCreateWithoutCareersInput>
    where?: ExamRecordWhereInput
  }

  export type ExamRecordUpdateToOneWithWhereWithoutCareersInput = {
    where?: ExamRecordWhereInput
    data: XOR<ExamRecordUpdateWithoutCareersInput, ExamRecordUncheckedUpdateWithoutCareersInput>
  }

  export type ExamRecordUpdateWithoutCareersInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput
    board?: BoardUpdateOneRequiredWithoutExamRecordsNestedInput
    position?: PositionUpdateOneRequiredWithoutExamRecordsNestedInput
    notice?: NoticeUpdateOneWithoutExamRecordsNestedInput
    areas?: ExamRecordAreaUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateWithoutCareersInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type CareerUpsertWithoutExamsInput = {
    update: XOR<CareerUpdateWithoutExamsInput, CareerUncheckedUpdateWithoutExamsInput>
    create: XOR<CareerCreateWithoutExamsInput, CareerUncheckedCreateWithoutExamsInput>
    where?: CareerWhereInput
  }

  export type CareerUpdateToOneWithWhereWithoutExamsInput = {
    where?: CareerWhereInput
    data: XOR<CareerUpdateWithoutExamsInput, CareerUncheckedUpdateWithoutExamsInput>
  }

  export type CareerUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCreateWithoutAreasInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutExamRecordsInput
    board: BoardCreateNestedOneWithoutExamRecordsInput
    position: PositionCreateNestedOneWithoutExamRecordsInput
    notice?: NoticeCreateNestedOneWithoutExamRecordsInput
    careers?: ExamRecordCareerCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateWithoutAreasInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    careers?: ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput
    parts?: ExamRecordPartUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordCreateOrConnectWithoutAreasInput = {
    where: ExamRecordWhereUniqueInput
    create: XOR<ExamRecordCreateWithoutAreasInput, ExamRecordUncheckedCreateWithoutAreasInput>
  }

  export type AreaCreateWithoutExamsInput = {
    id?: string
    externalId: number
    name: string
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AreaUncheckedCreateWithoutExamsInput = {
    id?: string
    externalId: number
    name: string
    slug?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AreaCreateOrConnectWithoutExamsInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutExamsInput, AreaUncheckedCreateWithoutExamsInput>
  }

  export type ExamRecordUpsertWithoutAreasInput = {
    update: XOR<ExamRecordUpdateWithoutAreasInput, ExamRecordUncheckedUpdateWithoutAreasInput>
    create: XOR<ExamRecordCreateWithoutAreasInput, ExamRecordUncheckedCreateWithoutAreasInput>
    where?: ExamRecordWhereInput
  }

  export type ExamRecordUpdateToOneWithWhereWithoutAreasInput = {
    where?: ExamRecordWhereInput
    data: XOR<ExamRecordUpdateWithoutAreasInput, ExamRecordUncheckedUpdateWithoutAreasInput>
  }

  export type ExamRecordUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput
    board?: BoardUpdateOneRequiredWithoutExamRecordsNestedInput
    position?: PositionUpdateOneRequiredWithoutExamRecordsNestedInput
    notice?: NoticeUpdateOneWithoutExamRecordsNestedInput
    careers?: ExamRecordCareerUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careers?: ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type AreaUpsertWithoutExamsInput = {
    update: XOR<AreaUpdateWithoutExamsInput, AreaUncheckedUpdateWithoutExamsInput>
    create: XOR<AreaCreateWithoutExamsInput, AreaUncheckedCreateWithoutExamsInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutExamsInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutExamsInput, AreaUncheckedUpdateWithoutExamsInput>
  }

  export type AreaUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCreateWithoutPartsInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutExamRecordsInput
    board: BoardCreateNestedOneWithoutExamRecordsInput
    position: PositionCreateNestedOneWithoutExamRecordsInput
    notice?: NoticeCreateNestedOneWithoutExamRecordsInput
    careers?: ExamRecordCareerCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordUncheckedCreateWithoutPartsInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    careers?: ExamRecordCareerUncheckedCreateNestedManyWithoutExamRecordInput
    areas?: ExamRecordAreaUncheckedCreateNestedManyWithoutExamRecordInput
  }

  export type ExamRecordCreateOrConnectWithoutPartsInput = {
    where: ExamRecordWhereUniqueInput
    create: XOR<ExamRecordCreateWithoutPartsInput, ExamRecordUncheckedCreateWithoutPartsInput>
  }

  export type ExamRecordUpsertWithoutPartsInput = {
    update: XOR<ExamRecordUpdateWithoutPartsInput, ExamRecordUncheckedUpdateWithoutPartsInput>
    create: XOR<ExamRecordCreateWithoutPartsInput, ExamRecordUncheckedCreateWithoutPartsInput>
    where?: ExamRecordWhereInput
  }

  export type ExamRecordUpdateToOneWithWhereWithoutPartsInput = {
    where?: ExamRecordWhereInput
    data: XOR<ExamRecordUpdateWithoutPartsInput, ExamRecordUncheckedUpdateWithoutPartsInput>
  }

  export type ExamRecordUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput
    board?: BoardUpdateOneRequiredWithoutExamRecordsNestedInput
    position?: PositionUpdateOneRequiredWithoutExamRecordsNestedInput
    notice?: NoticeUpdateOneWithoutExamRecordsNestedInput
    careers?: ExamRecordCareerUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateWithoutPartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careers?: ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type QuestionCreateManyExamInput = {
    id?: string
    statement: string
    organization: string
    subject: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    statement?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeCreateManyQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlternativeUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationAnswerCreateManySimulationInput = {
    id?: string
    questionId: string
    alternativeId: string
    createdAt?: Date | string
  }

  export type SimulationAnswerUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationAnswerUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationAnswerUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCreateManyOrganizationInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    boardId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamRecordUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutExamRecordsNestedInput
    position?: PositionUpdateOneRequiredWithoutExamRecordsNestedInput
    notice?: NoticeUpdateOneWithoutExamRecordsNestedInput
    careers?: ExamRecordCareerUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careers?: ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCreateManyBoardInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    positionId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamRecordUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput
    position?: PositionUpdateOneRequiredWithoutExamRecordsNestedInput
    notice?: NoticeUpdateOneWithoutExamRecordsNestedInput
    careers?: ExamRecordCareerUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careers?: ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateManyWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCreateManyPositionInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    noticeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamRecordUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput
    board?: BoardUpdateOneRequiredWithoutExamRecordsNestedInput
    notice?: NoticeUpdateOneWithoutExamRecordsNestedInput
    careers?: ExamRecordCareerUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careers?: ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    noticeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCreateManyNoticeInput = {
    id?: string
    externalId: number
    slug: string
    name: string
    type: number
    year: number
    level: string
    questionCount: number
    durationMinutes?: number | null
    reviewed?: boolean
    hasPendencies?: boolean
    available?: boolean
    observations?: string | null
    otherData?: string | null
    timestamp?: Date | string | null
    publishedAt?: Date | string | null
    applicationDate?: Date | string | null
    examFileKey?: string | null
    answerKeyFileKey?: string | null
    organizationId: string
    boardId: string
    positionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamRecordUpdateWithoutNoticeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutExamRecordsNestedInput
    board?: BoardUpdateOneRequiredWithoutExamRecordsNestedInput
    position?: PositionUpdateOneRequiredWithoutExamRecordsNestedInput
    careers?: ExamRecordCareerUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateWithoutNoticeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careers?: ExamRecordCareerUncheckedUpdateManyWithoutExamRecordNestedInput
    areas?: ExamRecordAreaUncheckedUpdateManyWithoutExamRecordNestedInput
    parts?: ExamRecordPartUncheckedUpdateManyWithoutExamRecordNestedInput
  }

  export type ExamRecordUncheckedUpdateManyWithoutNoticeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    questionCount?: IntFieldUpdateOperationsInput | number
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    hasPendencies?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    otherData?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    answerKeyFileKey?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    boardId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamRecordCareerCreateManyCareerInput = {
    id?: string
    examRecordId: string
  }

  export type ExamRecordCareerUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecord?: ExamRecordUpdateOneRequiredWithoutCareersNestedInput
  }

  export type ExamRecordCareerUncheckedUpdateWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordCareerUncheckedUpdateManyWithoutCareerInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordAreaCreateManyAreaInput = {
    id?: string
    examRecordId: string
  }

  export type ExamRecordAreaUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecord?: ExamRecordUpdateOneRequiredWithoutAreasNestedInput
  }

  export type ExamRecordAreaUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordAreaUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    examRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordCareerCreateManyExamRecordInput = {
    id?: string
    careerId: string
  }

  export type ExamRecordAreaCreateManyExamRecordInput = {
    id?: string
    areaId: string
  }

  export type ExamRecordPartCreateManyExamRecordInput = {
    id?: string
    externalId?: number | null
    description: string
  }

  export type ExamRecordCareerUpdateWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    career?: CareerUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamRecordCareerUncheckedUpdateWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordCareerUncheckedUpdateManyWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    careerId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordAreaUpdateWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    area?: AreaUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamRecordAreaUncheckedUpdateWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordAreaUncheckedUpdateManyWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    areaId?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordPartUpdateWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordPartUncheckedUpdateWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ExamRecordPartUncheckedUpdateManyWithoutExamRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}